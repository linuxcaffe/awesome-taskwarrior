#!/bin/bash
#
# wrapper-template.install
#
# Template installer for wrapper applications
#
# INSTRUCTIONS:
# 1. Copy this file to installers/<yourapp>.install
# 2. Replace all <PLACEHOLDER> markers
# 3. Implement wrapper pass-through logic
# 4. Test with wrapper stack
# 5. Make executable: chmod +x installers/yourapp.install

# TODO: Replace with your full app name (matches .meta file)
# EXAMPLE: APPNAME="tw-nicedates"
APPNAME="<YOURAPP-NAME>"

# TODO: Replace with directory name (no 'tw-' prefix)
# EXAMPLE: SHORT_NAME="nicedates"
# NOTE: This creates ~/.task/scripts/<SHORT_NAME>/
SHORT_NAME="<SHORT-NAME>"

# TODO: Replace with your repository URL
# EXAMPLE: REPO_URL="https://github.com/username/nicedates"
REPO_URL="<https://github.com/USERNAME/REPO>"

# TODO: Replace with your wrapper executable name
# EXAMPLE: WRAPPER_EXEC="nicedates.py" or "nicedates"
# NOTE: This is the main script that will be called
WRAPPER_EXEC="<WRAPPER-SCRIPT-NAME>"

# TODO: Replace with the symlink name (usually without .py extension)
# EXAMPLE: LINK_NAME="nicedates"
# NOTE: This is what users will type: tw -> nicedates -> task
LINK_NAME="<LINK-NAME>"

# Source common library functions
source "$(dirname "$0")/../lib/tw-common.sh"

#
# REQUIRED: install() function
#
install() {
    echo "Installing ${APPNAME}..."
    
    # Step 1: Check dependencies
    # TODO: Add dependency checks for your wrapper
    # EXAMPLE: tw_check_python_version 3.6 || return 1
    # EXAMPLE: tw_check_command "dateutil" || return 1
    
    tw_check_taskwarrior_version 2.6.2 || return 1
    
    # Step 2: Clone repository to proper location
    # NOTE: This clones to ~/.task/scripts/<SHORT_NAME>/
    # EXAMPLE: tw_clone_to_project wrapper nicedates "https://github.com/user/nicedates"
    
    tw_clone_to_project wrapper "$SHORT_NAME" "$REPO_URL" || return 1
    
    local project_dir="${SCRIPTS_DIR}/${SHORT_NAME}"
    
    # Step 3: Create wrapper symlink
    # NOTE: Creates symlink in ~/.task/scripts/ pointing to executable in project
    # EXAMPLE: tw_symlink_wrapper "$project_dir" "nicedates.py" "nicedates"
    
    tw_symlink_wrapper "$project_dir" "$WRAPPER_EXEC" "$LINK_NAME" || return 1
    
    # Step 4: Add wrapper to PATH (if needed)
    # NOTE: User should add ~/.task/scripts to their PATH
    # EXAMPLE: export PATH="$HOME/.task/scripts:$PATH"
    
    if [[ ":$PATH:" != *":${SCRIPTS_DIR}:"* ]]; then
        tw_info "Add to your ~/.bashrc or ~/.zshrc:"
        tw_info "  export PATH=\"\$HOME/.task/scripts:\$PATH\""
    fi
    
    # Step 5: Add configuration (optional)
    # TODO: Add any wrapper-specific configuration
    # EXAMPLE: tw_add_config "wrapper.nicedates.format=%Y-%m-%d"
    
    # Step 6: Configure wrapper chaining (optional)
    # NOTE: If this wrapper should be part of a chain:
    # EXAMPLE: tw_add_config "tw.wrapper.chain=nicedates"
    
    echo "✓ Installed ${APPNAME}"
    echo "  Wrapper installed in: ${SCRIPTS_DIR}/"
    echo "  Project files in: ${project_dir}"
    echo "  Usage: ${LINK_NAME} <args>"
    return 0
}

#
# REQUIRED: uninstall() function
#
uninstall() {
    echo "Uninstalling ${APPNAME}..."
    
    # Step 1: Remove wrapper symlink
    tw_remove_wrapper "$LINK_NAME"
    
    # Step 2: Remove configuration
    # TODO: Remove any wrapper-specific configuration
    # EXAMPLE: tw_remove_config "wrapper.nicedates"
    # EXAMPLE: tw_remove_config "tw.wrapper.chain"
    
    # Step 3: Remove project directory
    rm -rf "${SCRIPTS_DIR}/${SHORT_NAME}"
    
    echo "✓ Uninstalled ${APPNAME}"
    return 0
}

#
# OPTIONAL: update() function
#
update() {
    echo "Updating ${APPNAME}..."
    
    local project_dir="${SCRIPTS_DIR}/${SHORT_NAME}"
    
    # Try git pull
    if [ -d "$project_dir/.git" ]; then
        tw_info "Pulling latest changes..."
        cd "$project_dir" && git pull || return 1
        echo "✓ Updated ${APPNAME}"
        return 0
    else
        # No git repo, trigger reinstall
        return 1
    fi
}

#
# OPTIONAL: test() function
#
test() {
    echo "Testing ${APPNAME}..."
    
    local project_dir="${SCRIPTS_DIR}/${SHORT_NAME}"
    
    # Test 1: Wrapper symlink exists and is executable
    local wrapper_path="${SCRIPTS_DIR}/${LINK_NAME}"
    if [ ! -L "$wrapper_path" ]; then
        tw_error "Wrapper symlink not found: $wrapper_path"
        return 1
    fi
    
    if [ ! -x "$wrapper_path" ]; then
        tw_error "Wrapper is not executable: $wrapper_path"
        return 1
    fi
    
    # Test 2: Project directory exists
    if [ ! -d "$project_dir" ]; then
        tw_error "Project directory not found: $project_dir"
        return 1
    fi
    
    # Test 3: Wrapper can execute
    # TODO: Add wrapper-specific test
    # EXAMPLE: $wrapper_path --version >/dev/null 2>&1 || return 1
    
    # Test 4: Configuration exists (if added)
    # TODO: Test wrapper configuration
    # EXAMPLE: tw_test_config "wrapper.nicedates.format" "%Y-%m-%d" || return 1
    
    echo "✓ All tests passed"
    return 0
}

# Main entry point
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    # Set defaults if not provided by environment
    : ${INSTALL_DIR:=~/.task}
    : ${HOOKS_DIR:=~/.task/hooks}
    : ${SCRIPTS_DIR:=~/.task/scripts}
    : ${CONFIG_DIR:=~/.task/config}
    : ${LOGS_DIR:=~/.task/logs}
    : ${TASKRC:=~/.taskrc}
    : ${TW_DEBUG:=0}
    
    # Route to appropriate function
    case "${1:-install}" in
        install) install ;;
        uninstall) uninstall ;;
        update) update ;;
        test) test ;;
        *)
            echo "Usage: $0 {install|uninstall|update|test}" >&2
            exit 1
            ;;
    esac
fi

# TEMPLATE NOTES:
#
# Wrapper Types:
#   1. Pass-through: Transparent wrapper that modifies arguments/output
#   2. Command: Adds new commands while still supporting task commands
#   3. Hybrid: Combination of both
#
# Directory Structure (v1.3.0+):
#   ~/.task/
#   ├── scripts/                # Wrapper symlinks (nicedates, etc.)
#   │   └── <SHORT_NAME>/       # Your project files
#   ├── hooks/                  # Hook symlinks
#   ├── config/                 # Config files
#   └── logs/                   # Debug and test logs
#
# Wrapper Implementation:
#   Wrappers should:
#   - Support TW_NEXT_WRAPPER env var for chaining
#   - Pass through unhandled commands to task
#   - Handle --version and --help gracefully
#   - Be fast (users notice slow wrappers)
#   - Provide clear error messages
#
# Key Functions (from tw-common.sh):
#   tw_clone_to_project         # Clone to scripts/<SHORT_NAME>/
#   tw_symlink_wrapper          # Create wrapper symlink
#   tw_remove_wrapper           # Remove wrapper symlink
#   tw_check_python_version     # Verify Python version
#   tw_check_taskwarrior_version # Verify Taskwarrior version
#   tw_check_command            # Verify command exists
#   tw_add_config               # Add taskrc configuration
#   tw_remove_config            # Remove taskrc configuration
#
# Environment Variables:
#   $INSTALL_DIR                # ~/.task (default)
#   $SCRIPTS_DIR                # ~/.task/scripts (default)
#   $HOOKS_DIR                  # ~/.task/hooks (default)
#   $CONFIG_DIR                 # ~/.task/config (default)
#   $LOGS_DIR                   # ~/.task/logs (default)
#   $TASKRC                     # ~/.taskrc (default)
#   $TW_DEBUG                   # 0 or 1
#
# Wrapper Chaining:
#   If TW_NEXT_WRAPPER is set, wrapper should call it instead of task:
#   
#   if [ -n "$TW_NEXT_WRAPPER" ]; then
#       exec "$TW_NEXT_WRAPPER" "$@"
#   else
#       exec task "$@"
#   fi
#
# PATH Configuration:
#   Wrappers must be in PATH to work. Users should add:
#   
#   export PATH="$HOME/.task/scripts:$PATH"
#   
#   to their shell RC file.
#
# Best Practices:
#   - Keep wrappers stateless when possible
#   - Use tw_* functions instead of direct commands
#   - Test with both standalone and chained usage
#   - Document wrapper behavior clearly
#   - Handle edge cases gracefully
#   - Provide examples in README
#
# See Also:
#   - dev/API.md for complete function reference
#   - dev/models/nicedates.install for working example
#   - DEVELOPERS.md for wrapper architecture
#   - lib/tw-wrapper.py for Python wrapper base class
