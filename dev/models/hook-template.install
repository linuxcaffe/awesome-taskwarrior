#!/usr/bin/env bash
#
# hook-template.install - Template for Taskwarrior hook installers
# Version: 2.0.0
#
# This template demonstrates the v2.0.0 architecture:
# - Self-contained (works standalone)
# - Optional tw-common.sh usage (graceful degradation)
# - Environment detection with defaults
# - Curl-based file downloads
# - Direct file placement (no symlinks by default)
#
# USAGE:
#   bash myapp.install install   - Install the application
#   bash myapp.install remove    - Remove the application
#
# ENVIRONMENT VARIABLES:
#   HOOKS_DIR    - Target directory for hooks (default: ~/.task/hooks)
#   CONFIG_DIR   - Target directory for configs (default: ~/.task/config)
#   DOCS_DIR     - Target directory for docs (default: ~/.task/docs)
#   TASKRC       - Taskwarrior config file (default: ~/.taskrc)
#   TW_DEBUG     - Enable debug output (set to any value)

set -euo pipefail

#=============================================================================
# CONFIGURATION
#=============================================================================

APP_NAME="myapp"
APP_VERSION="1.0.0"
BASE_URL="https://raw.githubusercontent.com/username/myapp/main"

# Files to download (update this list for your app)
declare -A FILES=(
    ["on-add_${APP_NAME}.py"]="hook"
    ["on-modify_${APP_NAME}.py"]="hook"
    ["${APP_NAME}.rc"]="config"
    ["README.md"]="doc"
)

#=============================================================================
# OPTIONAL HELPER SOURCING
#=============================================================================

if [[ -f ~/.task/lib/tw-common.sh ]]; then
    source ~/.task/lib/tw-common.sh
else
    # Fallback: Define minimal messaging functions inline
    tw_msg() { echo "[INFO] $*"; }
    tw_success() { echo "[SUCCESS] $*"; }
    tw_warn() { echo "[WARNING] $*" >&2; }
    tw_error() { echo "[ERROR] $*" >&2; }
    tw_die() { tw_error "$@"; exit 1; }
    tw_debug() { [[ -n "${TW_DEBUG:-}" ]] && echo "[DEBUG] $*" >&2 || true; }
fi

#=============================================================================
# ENVIRONMENT DETECTION
#=============================================================================

: ${HOOKS_DIR:=~/.task/hooks}
: ${SCRIPTS_DIR:=~/.task/scripts}
: ${CONFIG_DIR:=~/.task/config}
: ${DOCS_DIR:=~/.task/docs}
: ${TASKRC:=~/.taskrc}

#=============================================================================
# HELPER FUNCTIONS
#=============================================================================

check_requirements() {
    tw_msg "Checking requirements..."
    
    # Check for curl
    if ! command -v curl &>/dev/null; then
        tw_die "curl is required but not found. Please install curl."
    fi
    
    # Check for Taskwarrior
    if ! command -v task &>/dev/null; then
        tw_die "Taskwarrior is required but not found. Please install Taskwarrior."
    fi
    
    # Optional: Check versions if tw-common.sh is available
    if type tw_check_taskwarrior_version &>/dev/null; then
        tw_check_taskwarrior_version "2.6.0" || return 1
    fi
    
    if type tw_check_python_version &>/dev/null; then
        tw_check_python_version "3.6" || return 1
    fi
    
    tw_success "Requirements check passed"
    return 0
}

download_file() {
    local filename="$1"
    local url="${BASE_URL}/${filename}"
    local target_dir="$2"
    local target_name="${3:-$filename}"
    local target_path="${target_dir}/${target_name}"
    
    tw_debug "Downloading $url to $target_path"
    
    # Use tw_curl_and_place if available, else basic curl
    if type tw_curl_and_place &>/dev/null; then
        tw_curl_and_place "$url" "$target_dir" "$target_name" || return 1
    else
        # Ensure directory exists
        mkdir -p "$target_dir" || {
            tw_error "Failed to create directory: $target_dir"
            return 1
        }
        
        # Download to temp file first
        local tmp_file
        tmp_file=$(mktemp) || {
            tw_error "Failed to create temporary file"
            return 1
        }
        
        if ! curl -fsSL "$url" -o "$tmp_file"; then
            tw_error "Failed to download: $url"
            rm -f "$tmp_file"
            return 1
        fi
        
        # Move to final location
        if ! mv "$tmp_file" "$target_path"; then
            tw_error "Failed to move file to: $target_path"
            rm -f "$tmp_file"
            return 1
        fi
        
        tw_success "Downloaded: $target_name"
    fi
    
    return 0
}

#=============================================================================
# INSTALL FUNCTION
#=============================================================================

install() {
    tw_msg "Installing $APP_NAME v$APP_VERSION..."
    
    # Check requirements
    check_requirements || return 1
    
    # Create directories
    mkdir -p "$HOOKS_DIR" "$CONFIG_DIR" "$DOCS_DIR"
    
    # Download files based on type
    for filename in "${!FILES[@]}"; do
        local file_type="${FILES[$filename]}"
        
        case "$file_type" in
            hook)
                download_file "$filename" "$HOOKS_DIR" || return 1
                # Make hooks executable
                chmod +x "$HOOKS_DIR/$filename"
                ;;
            config)
                download_file "$filename" "$CONFIG_DIR" || return 1
                ;;
            doc)
                # Rename README.md to appname_README.md to avoid conflicts
                if [[ "$filename" == "README.md" ]]; then
                    download_file "$filename" "$DOCS_DIR" "${APP_NAME}_README.md" || return 1
                else
                    download_file "$filename" "$DOCS_DIR" || return 1
                fi
                ;;
            *)
                tw_warn "Unknown file type: $file_type for $filename"
                ;;
        esac
    done
    
    # Configure Taskwarrior
    configure_taskwarrior || return 1
    
    tw_success "Successfully installed $APP_NAME v$APP_VERSION"
    tw_msg "Files installed to:"
    tw_msg "  Hooks: $HOOKS_DIR"
    tw_msg "  Config: $CONFIG_DIR"
    tw_msg "  Docs: $DOCS_DIR"
    
    return 0
}

configure_taskwarrior() {
    tw_msg "Configuring Taskwarrior..."
    
    local config_line="include $CONFIG_DIR/${APP_NAME}.rc"
    
    # Check if .taskrc exists
    if [[ ! -f "$TASKRC" ]]; then
        tw_warn ".taskrc not found at $TASKRC"
        tw_warn "Please add manually: $config_line"
        return 0
    fi
    
    # Add config using helper if available, else manual
    if type tw_add_config &>/dev/null; then
        tw_add_config "$config_line" || return 1
    else
        # Check if already exists (idempotent)
        if grep -Fxq "$config_line" "$TASKRC"; then
            tw_debug "Config already exists in .taskrc"
        else
            echo "$config_line" >> "$TASKRC" || {
                tw_error "Failed to add config to .taskrc"
                return 1
            }
            tw_success "Added config to .taskrc"
        fi
    fi
    
    return 0
}

#=============================================================================
# REMOVE FUNCTION
#=============================================================================

remove() {
    tw_msg "Removing $APP_NAME..."
    
    # Remove hook files
    for filename in "${!FILES[@]}"; do
        local file_type="${FILES[$filename]}"
        
        case "$file_type" in
            hook)
                local file_path="$HOOKS_DIR/$filename"
                if [[ -f "$file_path" ]]; then
                    rm -f "$file_path"
                    tw_success "Removed: $file_path"
                fi
                ;;
            config)
                local file_path="$CONFIG_DIR/$filename"
                if [[ -f "$file_path" ]]; then
                    rm -f "$file_path"
                    tw_success "Removed: $file_path"
                fi
                ;;
            doc)
                # Handle renamed README
                if [[ "$filename" == "README.md" ]]; then
                    local file_path="$DOCS_DIR/${APP_NAME}_README.md"
                else
                    local file_path="$DOCS_DIR/$filename"
                fi
                if [[ -f "$file_path" ]]; then
                    rm -f "$file_path"
                    tw_success "Removed: $file_path"
                fi
                ;;
        esac
    done
    
    # Remove config from .taskrc
    remove_config || return 1
    
    tw_success "Successfully removed $APP_NAME"
    
    return 0
}

remove_config() {
    local config_line="include $CONFIG_DIR/${APP_NAME}.rc"
    
    # Check if .taskrc exists
    if [[ ! -f "$TASKRC" ]]; then
        tw_debug ".taskrc not found, nothing to remove"
        return 0
    fi
    
    # Remove using helper if available, else manual
    if type tw_remove_config &>/dev/null; then
        tw_remove_config "$config_line"
    else
        # Check if config exists
        if ! grep -Fxq "$config_line" "$TASKRC"; then
            tw_debug "Config not found in .taskrc"
            return 0
        fi
        
        # Remove config line
        local tmp_file
        tmp_file=$(mktemp) || {
            tw_error "Failed to create temporary file"
            return 1
        }
        
        if grep -Fxv "$config_line" "$TASKRC" > "$tmp_file" 2>/dev/null; then
            mv "$tmp_file" "$TASKRC"
            tw_success "Removed config from .taskrc"
        else
            tw_warn "Failed to remove config from .taskrc"
            rm -f "$tmp_file"
        fi
    fi
    
    return 0
}

#=============================================================================
# MAIN DISPATCHER
#=============================================================================

case "${1:-}" in
    install)
        install
        ;;
    remove|uninstall)
        remove
        ;;
    *)
        echo "Usage: $0 {install|remove}"
        echo ""
        echo "Install or remove $APP_NAME hook for Taskwarrior"
        echo ""
        echo "Commands:"
        echo "  install   - Download and install $APP_NAME"
        echo "  remove    - Remove $APP_NAME and clean up"
        exit 1
        ;;
esac
