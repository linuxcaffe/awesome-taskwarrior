#!/usr/bin/env bash
#
# hook-template.install - Self-contained installer template for Taskwarrior hooks
# Version: 2.0.0
#
# This template demonstrates the v2.0.0 architecture:
# - Self-contained (works standalone without tw.py)
# - Optional tw-common.sh usage (graceful degradation)
# - Environment detection with defaults
# - Curl-based file downloads
# - Direct file placement
# - Manifest tracking
#
# USAGE:
#   bash yourapp.install install   - Install the application
#   bash yourapp.install remove    - Remove the application
#
# ENVIRONMENT VARIABLES (set by tw.py or override manually):
#   HOOKS_DIR     - Hook installation directory (default: ~/.task/hooks)
#   SCRIPTS_DIR   - Script installation directory (default: ~/.task/scripts)
#   CONFIG_DIR    - Config file directory (default: ~/.task/config)
#   DOCS_DIR      - Documentation directory (default: ~/.task/docs)
#   TASKRC        - Taskwarrior config file (default: ~/.taskrc)
#   TW_COMMON     - Path to tw-common.sh library
#   TW_DEBUG      - Enable debug output (0 or 1)
#

set -euo pipefail

#------------------------------------------------------------------------------
# APPLICATION METADATA
#------------------------------------------------------------------------------

APPNAME="myapp"
VERSION="1.0.0"
BASE_URL="https://raw.githubusercontent.com/username/project/main"

#------------------------------------------------------------------------------
# ENVIRONMENT DETECTION
#------------------------------------------------------------------------------

# These defaults allow the installer to work standalone
: "${HOOKS_DIR:=$HOME/.task/hooks}"
: "${SCRIPTS_DIR:=$HOME/.task/scripts}"
: "${CONFIG_DIR:=$HOME/.task/config}"
: "${DOCS_DIR:=$HOME/.task/docs}"
: "${LOGS_DIR:=$HOME/.task/logs}"
: "${TASKRC:=$HOME/.taskrc}"
: "${TW_DEBUG:=0}"

#------------------------------------------------------------------------------
# LIBRARY SOURCING (OPTIONAL)
#------------------------------------------------------------------------------

# Try to source tw-common.sh for helper functions
# If not available, we'll use fallback implementations
if [[ -f "${TW_COMMON:-}" ]]; then
    source "$TW_COMMON"
    HAVE_TW_COMMON=1
else
    HAVE_TW_COMMON=0
    
    # Fallback messaging functions for standalone use
    tw_msg() {
        echo "[tw] $*"
    }
    
    tw_success() {
        echo "[tw] ✓ $*"
    }
    
    tw_error() {
        echo "[tw] ✗ $*" >&2
    }
    
    tw_warn() {
        echo "[tw] ⚠ $*" >&2
    }
    
    tw_debug() {
        if [[ "${TW_DEBUG:-0}" == "1" ]]; then
            echo "[tw-debug] $*" >&2
        fi
    }
fi

#------------------------------------------------------------------------------
# INSTALLATION FUNCTION
#------------------------------------------------------------------------------

install() {
    tw_msg "Installing $APPNAME v$VERSION..."
    
    # Create directories
    mkdir -p "$HOOKS_DIR" "$CONFIG_DIR" "$DOCS_DIR"
    
    # Download hook files
    tw_msg "Downloading hook files..."
    
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_curl_and_place &>/dev/null; then
        # Use tw-common.sh helpers if available
        tw_curl_and_place "$BASE_URL/on-add_${APPNAME}.py" "$HOOKS_DIR" || {
            tw_error "Failed to download on-add hook"
            return 1
        }
        
        tw_curl_and_place "$BASE_URL/on-modify_${APPNAME}.py" "$HOOKS_DIR" || {
            tw_error "Failed to download on-modify hook"
            return 1
        }
    else
        # Fallback for standalone use
        if ! curl -fsSL "$BASE_URL/on-add_${APPNAME}.py" -o "$HOOKS_DIR/on-add_${APPNAME}.py"; then
            tw_error "Failed to download on-add hook"
            return 1
        fi
        
        if ! curl -fsSL "$BASE_URL/on-modify_${APPNAME}.py" -o "$HOOKS_DIR/on-modify_${APPNAME}.py"; then
            tw_error "Failed to download on-modify hook"
            return 1
        fi
    fi
    
    # Make hooks executable
    chmod +x "$HOOKS_DIR/on-add_${APPNAME}.py"
    chmod +x "$HOOKS_DIR/on-modify_${APPNAME}.py"
    tw_debug "Made hooks executable"
    
    # Download config file
    tw_msg "Downloading configuration..."
    
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_curl_and_place &>/dev/null; then
        tw_curl_and_place "$BASE_URL/${APPNAME}.rc" "$CONFIG_DIR" || {
            tw_warn "Failed to download config file (continuing)"
        }
    else
        if ! curl -fsSL "$BASE_URL/${APPNAME}.rc" -o "$CONFIG_DIR/${APPNAME}.rc"; then
            tw_warn "Failed to download config file (continuing)"
        fi
    fi
    
    # Add config include to .taskrc
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_add_config &>/dev/null; then
        tw_add_config "include $CONFIG_DIR/${APPNAME}.rc"
    else
        # Fallback: manual config addition
        if [[ -f "$TASKRC" ]] && ! grep -q "include $CONFIG_DIR/${APPNAME}.rc" "$TASKRC"; then
            echo "include $CONFIG_DIR/${APPNAME}.rc" >> "$TASKRC"
            tw_debug "Added config include to .taskrc"
        elif [[ ! -f "$TASKRC" ]]; then
            echo "include $CONFIG_DIR/${APPNAME}.rc" > "$TASKRC"
            tw_debug "Created .taskrc with config include"
        fi
    fi
    
    # Download README
    tw_msg "Downloading documentation..."
    
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_curl_and_place &>/dev/null; then
        tw_curl_and_place "$BASE_URL/README.md" "$DOCS_DIR" "${APPNAME}_README.md" || {
            tw_warn "Failed to download README (continuing)"
        }
    else
        if ! curl -fsSL "$BASE_URL/README.md" -o "$DOCS_DIR/${APPNAME}_README.md"; then
            tw_warn "Failed to download README (continuing)"
        fi
    fi
    
    # Track installation in manifest (if tw-common.sh available)
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_manifest_add &>/dev/null; then
        tw_manifest_add "$APPNAME" "$VERSION" "$HOOKS_DIR/on-add_${APPNAME}.py"
        tw_manifest_add "$APPNAME" "$VERSION" "$HOOKS_DIR/on-modify_${APPNAME}.py"
        tw_manifest_add "$APPNAME" "$VERSION" "$CONFIG_DIR/${APPNAME}.rc"
        tw_manifest_add "$APPNAME" "$VERSION" "$DOCS_DIR/${APPNAME}_README.md"
        tw_debug "Added entries to manifest"
    fi
    
    tw_success "Installed $APPNAME v$VERSION"
    tw_msg "Hook files: $HOOKS_DIR/on-{add,modify}_${APPNAME}.py"
    tw_msg "Config: $CONFIG_DIR/${APPNAME}.rc"
    tw_msg "Documentation: $DOCS_DIR/${APPNAME}_README.md"
    
    return 0
}

#------------------------------------------------------------------------------
# REMOVAL FUNCTION
#------------------------------------------------------------------------------

remove() {
    tw_msg "Removing $APPNAME..."
    
    # Use manifest-based removal if available
    if [[ $HAVE_TW_COMMON -eq 1 ]] && type tw_uninstall_app &>/dev/null; then
        tw_uninstall_app "$APPNAME"
        return $?
    fi
    
    # Fallback: manual removal for standalone use
    local removed=0
    
    if [[ -f "$HOOKS_DIR/on-add_${APPNAME}.py" ]]; then
        rm -f "$HOOKS_DIR/on-add_${APPNAME}.py"
        tw_debug "Removed: $HOOKS_DIR/on-add_${APPNAME}.py"
        removed=1
    fi
    
    if [[ -f "$HOOKS_DIR/on-modify_${APPNAME}.py" ]]; then
        rm -f "$HOOKS_DIR/on-modify_${APPNAME}.py"
        tw_debug "Removed: $HOOKS_DIR/on-modify_${APPNAME}.py"
        removed=1
    fi
    
    if [[ -f "$CONFIG_DIR/${APPNAME}.rc" ]]; then
        rm -f "$CONFIG_DIR/${APPNAME}.rc"
        tw_debug "Removed: $CONFIG_DIR/${APPNAME}.rc"
        removed=1
    fi
    
    if [[ -f "$DOCS_DIR/${APPNAME}_README.md" ]]; then
        rm -f "$DOCS_DIR/${APPNAME}_README.md"
        tw_debug "Removed: $DOCS_DIR/${APPNAME}_README.md"
        removed=1
    fi
    
    # Remove config line from .taskrc
    if [[ -f "$TASKRC" ]]; then
        if grep -q "include $CONFIG_DIR/${APPNAME}.rc" "$TASKRC"; then
            grep -v "include $CONFIG_DIR/${APPNAME}.rc" "$TASKRC" > "$TASKRC.tmp" || true
            mv "$TASKRC.tmp" "$TASKRC"
            tw_debug "Removed config include from .taskrc"
        fi
    fi
    
    if [[ $removed -eq 1 ]]; then
        tw_success "Removed $APPNAME"
        return 0
    else
        tw_warn "No files found to remove for $APPNAME"
        return 1
    fi
}

#------------------------------------------------------------------------------
# MAIN ENTRY POINT
#------------------------------------------------------------------------------

main() {
    case "${1:-}" in
        install)
            install
            ;;
        remove)
            remove
            ;;
        *)
            echo "Usage: $0 {install|remove}"
            echo ""
            echo "Examples:"
            echo "  $0 install   - Install $APPNAME"
            echo "  $0 remove    - Remove $APPNAME"
            exit 1
            ;;
    esac
}

main "$@"
