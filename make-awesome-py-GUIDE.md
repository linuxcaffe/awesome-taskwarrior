# make-awesome.py v3.0.0

## Smart Debug Enhancement Tool for Awesome-Taskwarrior Extensions

### Overview

`make-awesome.py` is an intelligent Python tool that enhances Python files with sophisticated debug infrastructure while respecting existing code patterns. Unlike simple templating approaches, it **analyzes** existing code and **enhances** rather than replaces.

### Key Features

#### 1. Smart Pattern Detection
- **Detects existing debug variables** (DEBUG, DEBUG_MODE, debug, etc.)
- **Detects existing debug functions** (debug_print, debug_log, log_debug, etc.)
- **Detects TW_DEBUG support** (environment variable checks)
- **Identifies path constants** (CONFIG_DIR, HOOK_DIR, etc.) to preserve

#### 2. Intelligent Enhancement
- **Preserves existing debug infrastructure** - doesn't replace, enhances
- **Maintains original DEBUG values** - if DEBUG=1, keeps it as 1
- **Keeps imports together** - all imports at the top, not split
- **Never modifies path constants** - CONFIG_DIR stays CONFIG_DIR
- **Adds file logging** - wraps existing debug functions with file output
- **Adds TW_DEBUG support** - if not present, adds environment variable support

#### 3. Production-Ready Output
- **Auto-detects dev vs production mode** based on .git directory presence
- **Separate log locations**:
  - Dev mode: `./logs/debug/`
  - Production mode: `~/.task/logs/debug/`
- **Session-based logging** with timestamps
- **Automatic log file cleanup** (old logs in separate session files)

### Usage

```bash
# Basic usage - enhance all Python files in current directory
python3 make-awesome.py --debug

# Or if executable:
./make-awesome.py --debug
```

### What It Does

#### For Files WITH Existing Debug Code

Example input (nn-before):
```python
#!/usr/bin/env python3
"""docstring"""

import sys
import os
import subprocess
import json

# Configuration
CONFIG_DIR = os.path.expanduser("~/.task/config")
CONFIG_FILE = os.path.join(CONFIG_DIR, "need.rc")

# Debug mode - set to 1 to enable debug output
DEBUG = 1

def debug_print(msg):
    """Print debug message if DEBUG is enabled"""
    if DEBUG:
        print(f"DEBUG: {msg}")
```

Enhanced output (debug.nn):
```python
#!/usr/bin/env python3
"""docstring"""

# ============================================================================
# DEBUG ENHANCED VERSION - Auto-generated by make-awesome.py
# ============================================================================

import os
import sys
from pathlib import Path
from datetime import datetime
import subprocess
import json

# ============================================================================
# Enhanced Debug Infrastructure
# ============================================================================

# Check if running under tw --debug
tw_debug_level = os.environ.get('TW_DEBUG', '0')
try:
    tw_debug_level = int(tw_debug_level)
except ValueError:
    tw_debug_level = 0

# Determine log directory based on context
def get_log_dir():
    """Auto-detect dev vs production mode"""
    cwd = Path.cwd()
    
    # Dev mode: running from project directory (has .git)
    if (cwd / '.git').exists():
        log_dir = cwd / 'logs' / 'debug'
    else:
        # Production mode: installed and triggered by tw --debug
        log_dir = Path.home() / '.task' / 'logs' / 'debug'
    
    log_dir.mkdir(parents=True, exist_ok=True)
    return log_dir

# ============================================================================
# Original Code with Debug Enhancements
# ============================================================================

CONFIG_DIR = os.path.expanduser("~/.task/config")  # PRESERVED!
CONFIG_FILE = os.path.join(CONFIG_DIR, "need.rc")

# Debug mode - set to 1 to enable debug output
DEBUG = 1  # PRESERVED at 1!

# Original debug variable preserved: DEBUG = 1
def debug_print(msg):
    """Print debug message if DEBUG is enabled"""
    if DEBUG:
        print(f"DEBUG: {msg}")

# ... rest of original code ...

# ============================================================================
# Enhanced Debug Logging Wrapper
# ============================================================================

# Save original debug_print
_original_debug_print = debug_print

# Initialize enhanced debug logging
if DEBUG or tw_debug_level > 0:
    DEBUG_LOG_DIR = get_log_dir()
    DEBUG_SESSION_ID = datetime.now().strftime("%Y%m%d_%H%M%S")
    # Get script name from __file__ or argv[0]
    try:
        script_name = Path(__file__).stem
    except:
        script_name = Path(sys.argv[0]).stem if sys.argv else "script"
    DEBUG_LOG_FILE = DEBUG_LOG_DIR / f"{script_name}_debug_{DEBUG_SESSION_ID}.log"
    
    # Enhanced debug_print with file logging
    def debug_print(msg):
        """Enhanced debug with file logging"""
        if DEBUG or tw_debug_level > 0:
            timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            log_line = f"{timestamp} [DEBUG] {msg}\n"
            
            # Write to log file
            with open(DEBUG_LOG_FILE, "a") as f:
                f.write(log_line)
            
            # Call original function for console output
            _original_debug_print(msg)
    
    # Initialize log file with header
    with open(DEBUG_LOG_FILE, "w") as f:
        f.write("=" * 70 + "\n")
        f.write(f"Debug Session - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Script: {script_name}\n")
        f.write(f"DEBUG: {DEBUG}\n")
        f.write(f"TW_DEBUG Level: {tw_debug_level}\n")
        f.write(f"Session ID: {DEBUG_SESSION_ID}\n")
        f.write(f"Log File: {DEBUG_LOG_FILE}\n")
        f.write("=" * 70 + "\n\n")
    
    debug_print("Debug logging initialized")
```

#### For Files WITHOUT Existing Debug Code

If no debug infrastructure is found, `make-awesome.py` adds complete debug boilerplate with:
- `DEBUG_MODE` variable
- `debug_log(message, level=1)` function
- `TW_DEBUG` environment variable support
- Auto-detection of dev vs production mode
- File and console logging

### Key Improvements Over make-awesome.sh

| Feature | make-awesome.sh | make-awesome.py |
|---------|----------------|-----------------|
| **Import handling** | Splits imports with 65 lines of code | Keeps all imports together at top |
| **Existing debug** | Disables (sets DEBUG=0) | Preserves and enhances |
| **Path constants** | Modifies (CONFIG_DIR → HOOK_DIR) | Preserves original paths |
| **Pattern detection** | None - templating only | Smart analysis before enhancement |
| **Debug functions** | Replaces with new names | Wraps existing functions |
| **Code analysis** | Bash string matching | Python AST-aware parsing |

### What Gets Fixed

#### Problem 1: Path Mutations ❌ → ✅
**Before (make-awesome.sh output):**
```python
HOOK_DIR = os.path.expanduser("~/.task/hooks")  # WRONG!
CONFIG_FILE = os.path.join(HOOK_DIR, "need.rc")
```

**After (make-awesome.py output):**
```python
CONFIG_DIR = os.path.expanduser("~/.task/config")  # PRESERVED!
CONFIG_FILE = os.path.join(CONFIG_DIR, "need.rc")
```

#### Problem 2: Import Splitting ❌ → ✅
**Before (make-awesome.sh output):**
```python
import os
import sys
from pathlib import Path
from datetime import datetime

# ... 65 lines of debug boilerplate ...

import subprocess  # SPLIT!
import json
```

**After (make-awesome.py output):**
```python
import os
import sys
from pathlib import Path
from datetime import datetime
import subprocess
import json

# ... debug boilerplate ...
```

#### Problem 3: Debug Disabling ❌ → ✅
**Before (make-awesome.sh output):**
```python
DEBUG = 0  # Changed from 1 to 0!
```

**After (make-awesome.py output):**
```python
DEBUG = 1  # PRESERVED!
```

### Testing Your Enhanced Files

After running `make-awesome.py --debug`, you'll have `debug.*` versions of your Python files.

#### Test 1: Verify Paths Are Correct
```bash
# Check that CONFIG_DIR is still ~/.task/config
grep "CONFIG_DIR" debug.nn
# Should show: CONFIG_DIR = os.path.expanduser("~/.task/config")
```

#### Test 2: Verify Imports Are Together
```bash
# Check that all imports are at the top
head -50 debug.nn | grep -A 20 "import"
# Should show all imports in one block, not split
```

#### Test 3: Verify DEBUG Value Preserved
```bash
# Check that DEBUG is still 1
grep "^DEBUG = " debug.nn
# Should show: DEBUG = 1 (not DEBUG = 0)
```

#### Test 4: Run and Check Logging
```bash
# Run the script (if it's executable)
./debug.nn

# Check that log file was created
ls -la ./logs/debug/
# Should see: nn_debug_YYYYMMDD_HHMMSS.log

# Check log contents
cat ./logs/debug/nn_debug_*.log
```

### Workflow Integration

#### Typical Development Workflow

1. **Initial Development**
   ```bash
   # Write your Python file with basic debug
   vim my-hook.py
   ```

2. **Enhance with Debug Infrastructure**
   ```bash
   # Run make-awesome.py
   python3 make-awesome.py --debug
   ```

3. **Test Enhanced Version**
   ```bash
   # Test the debug version
   ./debug.my-hook.py
   
   # Check logs
   cat ./logs/debug/my-hook_debug_*.log
   ```

4. **Promote to Production**
   ```bash
   # Backup original
   mv my-hook.py my-hook.py.orig
   
   # Promote debug version
   mv debug.my-hook.py my-hook.py
   
   # Commit to git
   git add my-hook.py
   git commit -m "Add debug infrastructure"
   ```

### Compatibility

- **Python**: Requires Python 3.6+
- **Taskwarrior**: Works with Taskwarrior 2.6.x
- **Environment**: Works in both dev (project directory) and production (~/.task/)

### Safety Features

1. **Skip Already Enhanced**: Won't re-enhance files that already have the marker
2. **Preserve Executability**: Maintains executable bit from original file
3. **Non-Destructive**: Creates new `debug.*` files, doesn't overwrite originals

### Advanced Usage

#### Enhance Specific File
```python
from make_awesome import process_python_file
process_python_file('my-script.py', output_dir='./enhanced/')
```

#### Batch Processing
```bash
# Enhance all hooks
for f in on-*.py; do
    python3 make-awesome.py --debug
done
```

### Troubleshooting

#### "No Python files found"
- Make sure you're in the right directory
- Check that files have `.py` extension or Python shebang
- Make files executable if needed: `chmod +x my-script`

#### "Already enhanced, skipping"
- Remove the `debug.*` file to regenerate
- Or remove the auto-generated marker from the source file

#### Logs not appearing
- Check that DEBUG=1 in the file
- Or set TW_DEBUG=1 environment variable
- Verify log directory exists and is writable

### Future Enhancements

Potential future features:
- Support for bash script enhancement
- Configurable debug levels (1-5)
- Integration with awesome-taskwarrior registry
- Automatic test generation
- Debug visualization tools

### Contributing

This tool is part of the awesome-taskwarrior ecosystem. Improvements welcome!

---

**Version**: 3.0.0  
**Author**: David (awesome-taskwarrior maintainer)  
**License**: MIT
