#!/usr/bin/env python3
"""
tw - awesome-taskwarrior package manager and wrapper
Version: 2.7.0

A unified wrapper for Taskwarrior that provides:
- Transparent pass-through to task command
- Package management for Taskwarrior extensions (hooks, wrappers, configs)
- Curl-based installation (no git clones)
- Per-file manifest tracking
- Checksum verification
- Dev mode indicator for local development

Architecture Changes in v2.0.0:
- Removed git-based operations
- Direct file placement via curl
- Per-file manifest tracking (app|version|file|checksum|date)
- Added docs_dir for README files
- Self-contained installers that work with or without tw

Updates in v2.7.0:
- Fixed: Removed duplicated function definitions (generate_*_completion, main)
- Fixed: Safe update (tw -u) - preflight staging prevents data loss on failed updates
- Added: @0 shortcut for context none
- Added: @: contextname for one-shot context override (rc.context:name)
- Added: @_ for one-shot no-context override (rc.context:none)
- Added: @? shortcut for context show
- Added: Dot-shortcuts for recent tasks (. .. ... ....)

Updates in v2.2.0:
- Added: @ as alias for 'context' command
- Added: @+ to add context to current cmx set (context multiplexing)
- Added: @- to remove context from current cmx set
- Feature: Combine multiple contexts simultaneously with @+
- Compatible with standalone cmx.sh script
- Added: --generate-completion for bash/zsh/fish shell completions
- Feature: Tab completion for tw commands and task pass-through

Updates in v2.1.7:
- Fixed: -p/--pager now works correctly with all reports
- Fixed: Proper handling of empty args for default report
- Enhanced: Comprehensive limit/lines overrides for all report types
- Enhanced: Debug output shows exact shell command when TW_DEBUG_WRAPPER=1
- Improved: Simplified pager implementation using direct shell pipe

Updates in v2.1.6:
- Fixed: -A/--attach now correctly receives task ID argument
- Fixed: -p/--pager now preserves colors with rc._forcecolor=on
- Fixed: -p/--pager sets proper width with rc.defaultwidth
- Fixed: Less uses -R flag for better ANSI color handling
- Fixed: Flags with arguments properly included in argparse processing

Updates in v2.1.5:
- Added: -p/--pager flag for automatic paging of long task output
- Added: -A/--attach flag for attaching files to tasks via ranger
- Added: Shell exec/! commands for executing shell commands from interactive shell
- Added: !! command to repeat last shell command

Updates in v2.1.4:
- Fixed: Flags with = syntax now recognized (e.g., --debug=2)
- Fixed: Validation now handles --flag=value format properly
- Fixed: argparse limited to consecutive flags only

Updates in v2.1.3:
- Fixed: Flags must be first argument only (prevents false positives)
- Fixed: Flags must have trailing space (prevents partial matches)
- Fixed: Unknown flags now throw errors
- Enhanced: --version shows taskwarrior version and all installed extensions
- Added: TW_DEBUG_WRAPPER environment variable for argument parsing debug
- Renamed: All references from tw.py to tw

Updates in v2.1.2:
- Dev mode indicator shows when using local registry
- All unicode symbols replaced with ASCII equivalents
- Added PathManager.registry_dir property
"""

import sys
import os
import subprocess
import argparse
from pathlib import Path
from datetime import datetime
import hashlib
import shutil
import shlex
import readline
import json
import tempfile
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

VERSION = "2.7.0"

# GitHub configuration
GITHUB_REPO = "linuxcaffe/awesome-taskwarrior"
GITHUB_BRANCH = "main"
GITHUB_API_BASE = f"https://api.github.com/repos/{GITHUB_REPO}"
GITHUB_RAW_BASE = f"https://raw.githubusercontent.com/{GITHUB_REPO}/{GITHUB_BRANCH}"

# Shell configuration
SHELL_NAME = "tw"
SHELL_HISTFILE = os.path.expanduser("~/.task/config/.tw_shell_history")

# Global debug logger instance
debug_logger = None

def debug(message, level=1):
    """Log debug message if debug is enabled"""
    if debug_logger and debug_logger.level >= level:
        debug_logger.log(message, level)

class DebugLogger:
    """Manages debug output and logging"""
    
    def __init__(self, level=0, log_dir=None):
        self.level = level
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Set up log directory
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path.home() / ".task" / "logs" / "debug"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Create session log file
        if self.level > 0:
            self.log_file = self.log_dir / f"tw_debug_{self.session_id}.log"
            self._init_log()
            self._cleanup_old_logs()
        else:
            self.log_file = None
    
    def _init_log(self):
        """Initialize log file with header"""
        with open(self.log_file, 'w') as f:
            f.write(f"{'='*70}\n")
            f.write(f"tw Debug Session - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Debug Level: {self.level}\n")
            f.write(f"Session ID: {self.session_id}\n")
            f.write(f"{'='*70}\n\n")
    
    def _cleanup_old_logs(self, keep_last=10):
        """Keep only the last N debug session logs"""
        if not self.log_dir.exists():
            return
        
        log_files = sorted(self.log_dir.glob("tw_debug_*.log"))
        if len(log_files) > keep_last:
            for old_log in log_files[:-keep_last]:
                old_log.unlink()
    
    def log(self, message, level=1):
        """Log a debug message"""
        if level > self.level:
            return
        
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        prefix = f"[DEBUG-{level}]"
        
        # Write to file
        if self.log_file:
            with open(self.log_file, 'a') as f:
                f.write(f"{timestamp} {prefix} {message}\n")
        
        # Write to stderr with color
        colored_prefix = f"\033[34m{prefix}\033[0m"  # Blue
        print(f"{colored_prefix} {message}", file=sys.stderr)
    
    def set_environment(self):
        """Set TW_DEBUG environment variable for child processes"""
        os.environ['TW_DEBUG'] = str(self.level)
        debug(f"Set TW_DEBUG={self.level}", 1)

class TagFilter:
    """Parse and apply tag filters (+tag to include, -tag to exclude)"""
    
    def __init__(self, filter_args):
        """Parse filter arguments like ['+python', '-deprecated', '+hook']"""
        self.include_tags = []
        self.exclude_tags = []
        
        for arg in filter_args:
            if arg.startswith('+'):
                self.include_tags.append(arg[1:])
            elif arg.startswith('-'):
                self.exclude_tags.append(arg[1:])
    
    def matches(self, tags):
        """Check if a list of tags matches this filter
        
        Args:
            tags: List of tags (strings)
        
        Returns:
            True if matches filter, False otherwise
        """
        if not tags:
            tags = []
        
        # Must have all included tags
        for include_tag in self.include_tags:
            if include_tag not in tags:
                return False
        
        # Must not have any excluded tags
        for exclude_tag in self.exclude_tags:
            if exclude_tag in tags:
                return False
        
        return True
    
    def has_filters(self):
        """Check if any filters are set"""
        return bool(self.include_tags or self.exclude_tags)
    
    def __str__(self):
        """String representation for display"""
        parts = []
        for tag in self.include_tags:
            parts.append(f"+{tag}")
        for tag in self.exclude_tags:
            parts.append(f"-{tag}")
        return " ".join(parts) if parts else "(no filters)"

class PathManager:
    """Manages all filesystem paths for awesome-taskwarrior"""
    
    def __init__(self):
        self.home = Path.home()
        self.task_dir = self.home / ".task"
        self.hooks_dir = self.task_dir / "hooks"
        self.scripts_dir = self.task_dir / "scripts"
        self.config_dir = self.task_dir / "config"
        self.docs_dir = self.task_dir / "docs"
        self.logs_dir = self.task_dir / "logs"
        self.taskrc = self.home / ".taskrc"
        
        # Check if we're in a local repo (dev mode)
        self.tw_root = Path(__file__).parent.absolute()
        debug(f"PathManager: __file__ = {__file__}", 2)
        debug(f"PathManager: tw_root = {self.tw_root}", 2)
        
        self.local_registry = self.tw_root / "registry.d"
        self.local_installers = self.tw_root / "installers"
        self.lib_dir = self.tw_root / "lib"
        self.installed_dir = self.tw_root / "installed"
        self.manifest_file = self.config_dir / ".tw_manifest"
        
        # Determine mode: local (dev) or remote (production)
        self.is_dev_mode = self.local_registry.exists() and self.local_installers.exists()
        debug(f"Dev mode: {self.is_dev_mode}", 1)
        
        # Set registry_dir based on mode (for compatibility)
        self.registry_dir = self.local_registry if self.is_dev_mode else None
        
    def init_directories(self):
        """Create all required directories"""
        for dir_path in [
            self.hooks_dir, self.scripts_dir, self.config_dir,
            self.docs_dir, self.logs_dir, self.installed_dir
        ]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Only create registry and installers dirs in dev mode
        if self.is_dev_mode:
            self.local_registry.mkdir(parents=True, exist_ok=True)
            self.local_installers.mkdir(parents=True, exist_ok=True)

class RegistryManager:
    """Manages registry access - local files or GitHub API"""
    
    def __init__(self, paths):
        self.paths = paths
        self.is_dev_mode = paths.is_dev_mode
    
    def list_apps(self):
        """List all available applications from registry"""
        if self.is_dev_mode:
            return self._list_local_apps()
        else:
            return self._list_github_apps()
    
    def _list_local_apps(self):
        """List apps from local registry.d/ directory"""
        debug("Listing apps from local registry", 2)
        apps = []
        for meta_path in self.paths.local_registry.glob("*.meta"):
            apps.append(meta_path.stem)
        return sorted(apps)
    
    def _list_github_apps(self):
        """List apps from GitHub registry.d/ via API"""
        debug("Fetching apps from GitHub registry", 2)
        try:
            url = f"{GITHUB_API_BASE}/contents/registry.d"
            req = Request(url)
            req.add_header('Accept', 'application/vnd.github.v3+json')
            
            with urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
            
            apps = [item['name'][:-5] for item in data if item['name'].endswith('.meta')]
            debug(f"Found {len(apps)} apps on GitHub", 2)
            return sorted(apps)
        
        except (URLError, HTTPError) as e:
            print(f"[tw] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Â Failed to fetch registry from GitHub: {e}")
            return []
    
    def get_meta(self, app_name):
        """Get MetaFile object for an app"""
        if self.is_dev_mode:
            meta_path = self.paths.local_registry / f"{app_name}.meta"
            if meta_path.exists():
                return MetaFile(meta_path)
        else:
            # Fetch .meta from GitHub
            url = f"{GITHUB_RAW_BASE}/registry.d/{app_name}.meta"
            try:
                debug(f"Fetching {app_name}.meta from GitHub", 2)
                with urlopen(url, timeout=10) as response:
                    content = response.read().decode()
                
                # Create temporary file
                with tempfile.NamedTemporaryFile(mode='w', suffix='.meta', delete=False) as f:
                    f.write(content)
                    temp_path = f.name
                
                meta = MetaFile(temp_path)
                os.unlink(temp_path)
                return meta
            
            except (URLError, HTTPError) as e:
                debug(f"Failed to fetch {app_name}.meta: {e}", 1)
                return None
        
        return None
    
    def get_installer(self, app_name):
        """Get path to installer script (local or downloaded temp file)"""
        if self.is_dev_mode:
            installer_path = self.paths.local_installers / f"{app_name}.install"
            return installer_path if installer_path.exists() else None
        else:
            # Download installer from GitHub
            url = f"{GITHUB_RAW_BASE}/installers/{app_name}.install"
            try:
                debug(f"Downloading {app_name}.install from GitHub", 2)
                with urlopen(url, timeout=10) as response:
                    content = response.read().decode()
                
                # Create temporary file
                with tempfile.NamedTemporaryFile(mode='w', suffix='.install', delete=False) as f:
                    f.write(content)
                    temp_path = f.name
                
                # Make executable
                os.chmod(temp_path, 0o755)
                return Path(temp_path)
            
            except (URLError, HTTPError) as e:
                debug(f"Failed to download {app_name}.install: {e}", 1)
                return None

class MetaFile:
    """Parses and manages .meta files for applications"""
    
    def __init__(self, meta_path):
        self.meta_path = Path(meta_path)
        self.data = {}
        self._parse()
    
    def _parse(self):
        """Parse the .meta file"""
        if not self.meta_path.exists():
            return
        
        with open(self.meta_path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' in line:
                    key, value = line.split('=', 1)
                    self.data[key.strip()] = value.strip()
    
    def get(self, key, default=None):
        """Get a value from the meta file"""
        return self.data.get(key, default)
    
    def get_files(self):
        """Parse files= field into list of (filename, type) tuples
        
        Format: files=file1.py:hook,file2.sh:script,config.rc:config
        Returns: [('file1.py', 'hook'), ('file2.sh', 'script'), ...]
        """
        files_str = self.get('files', '')
        if not files_str:
            return []
        
        result = []
        for item in files_str.split(','):
            item = item.strip()
            if ':' in item:
                filename, file_type = item.split(':', 1)
                result.append((filename.strip(), file_type.strip()))
            else:
                # Default to 'file' type if not specified
                result.append((item, 'file'))
        
        return result
    
    def get_base_url(self):
        """Get base URL for file downloads"""
        return self.get('base_url', '')
    
    def get_checksums(self):
        """Parse checksums= field into list of checksums
        
        Format: checksums=hash1,hash2,hash3
        Returns: ['hash1', 'hash2', 'hash3']
        """
        checksums_str = self.get('checksums', '')
        if not checksums_str:
            return []
        
        return [c.strip() for c in checksums_str.split(',') if c.strip()]
    
    def get_tags(self):
        """Parse tags= field into list of tags
        
        Format: tags=python,hook,stable
        Returns: ['python', 'hook', 'stable']
        """
        tags_str = self.get('tags', '')
        if not tags_str:
            return []
        
        return [t.strip() for t in tags_str.split(',') if t.strip()]

class Manifest:
    """Manages the installation manifest"""
    
    def __init__(self, manifest_path):
        self.manifest_path = Path(manifest_path)
        self.entries = []
        self._load()
    
    def _load(self):
        """Load manifest from file"""
        if not self.manifest_path.exists():
            return
        
        with open(self.manifest_path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                parts = line.split('|')
                if len(parts) >= 5:
                    self.entries.append({
                        'app': parts[0],
                        'version': parts[1],
                        'file': parts[2],
                        'checksum': parts[3],
                        'date': parts[4]
                    })
    
    def add(self, app, version, file_path, checksum=''):
        """Add an entry to the manifest"""
        # Remove any existing entry for this file
        self.entries = [e for e in self.entries 
                       if not (e['app'] == app and e['file'] == file_path)]
        
        # Add new entry
        entry = {
            'app': app,
            'version': version,
            'file': file_path,
            'checksum': checksum,
            'date': datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')
        }
        self.entries.append(entry)
        self._save()
    
    def remove_app(self, app):
        """Remove all entries for an app"""
        self.entries = [e for e in self.entries if e['app'] != app]
        self._save()
    
    def get_files(self, app):
        """Get list of files for an app"""
        return [e['file'] for e in self.entries if e['app'] == app]
    
    def is_installed(self, app):
        """Check if an app is installed"""
        return any(e['app'] == app for e in self.entries)
    
    def get_version(self, app):
        """Get installed version of an app"""
        for e in self.entries:
            if e['app'] == app:
                return e['version']
        return None
    
    def _save(self):
        """Save manifest to file"""
        self.manifest_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.manifest_path, 'w') as f:
            for entry in self.entries:
                line = '|'.join([
                    entry['app'],
                    entry['version'],
                    entry['file'],
                    entry['checksum'],
                    entry['date']
                ])
                f.write(line + '\n')

class AppManager:
    """Manages application installation, removal, and updates"""
    
    def __init__(self, paths):
        self.paths = paths
        self.manifest = Manifest(paths.manifest_file)
        self.registry = RegistryManager(paths)
    
    def install(self, app_name, dry_run=False):
        """Install an application using its installer script"""
        debug(f"AppManager.install: Getting installer for {app_name}", 2)
        installer_path = self.registry.get_installer(app_name)
        is_temp_file = not self.paths.is_dev_mode
        
        if not installer_path:
            print(f"[tw] [X] Installer not found: {app_name}")
            return False
        
        debug(f"AppManager.install: Installer path: {installer_path}", 2)
        
        # Set environment variables for the installer
        env = os.environ.copy()
        env.update({
            'INSTALL_DIR': str(self.paths.task_dir),
            'HOOKS_DIR': str(self.paths.hooks_dir),
            'SCRIPTS_DIR': str(self.paths.scripts_dir),
            'CONFIG_DIR': str(self.paths.config_dir),
            'DOCS_DIR': str(self.paths.docs_dir),
            'LOGS_DIR': str(self.paths.logs_dir),
            'TASKRC': str(self.paths.taskrc),
            'TW_COMMON': str(self.paths.lib_dir / 'tw-common.sh')
        })
        
        if dry_run:
            env['TW_DRY_RUN'] = '1'
            print(f"[tw] DRY RUN: Would execute: bash {installer_path} install")
            
            # Show what would be installed
            meta = self.registry.get_meta(app_name)
            if meta:
                files = meta.get_files()
                if files:
                    print(f"[tw] Would install {len(files)} file(s):")
                    for filename, file_type in files:
                        target_dir = self._get_target_dir(file_type)
                        print(f"[tw]   {filename} -> {target_dir}/")
            
            # Clean up temp file if needed
            if is_temp_file and installer_path:
                os.unlink(installer_path)
            return True
        
        # Execute installer
        try:
            result = subprocess.run(
                ['bash', str(installer_path), 'install'],
                env=env,
                capture_output=False,
                text=True
            )
            
            # Clean up temp file if needed
            if is_temp_file and installer_path:
                os.unlink(installer_path)
            
            if result.returncode == 0:
                print(f"[tw] [+] Installed: {app_name}")
                return True
            else:
                print(f"[tw] [X] Installation failed: {app_name}")
                return False
                
        except Exception as e:
            # Clean up temp file if needed
            if is_temp_file and installer_path:
                try:
                    os.unlink(installer_path)
                except:
                    pass
            print(f"[tw] [X] Error running installer: {e}")
            return False
    
    def remove(self, app_name):
        """Remove an application using its installer script"""
        if not self.manifest.is_installed(app_name):
            print(f"[tw] [!] Not installed: {app_name}")
            return False
        
        debug(f"AppManager.remove: Getting installer for {app_name}", 2)
        installer_path = self.registry.get_installer(app_name)
        is_temp_file = not self.paths.is_dev_mode
        
        if installer_path:
            # Use installer's remove function
            env = os.environ.copy()
            env.update({
                'INSTALL_DIR': str(self.paths.task_dir),
                'HOOKS_DIR': str(self.paths.hooks_dir),
                'SCRIPTS_DIR': str(self.paths.scripts_dir),
                'CONFIG_DIR': str(self.paths.config_dir),
                'DOCS_DIR': str(self.paths.docs_dir),
                'LOGS_DIR': str(self.paths.logs_dir),
                'TASKRC': str(self.paths.taskrc),
                'TW_COMMON': str(self.paths.lib_dir / 'tw-common.sh')
            })
            
            try:
                result = subprocess.run(
                    ['bash', str(installer_path), 'remove'],
                    env=env,
                    capture_output=False
                )
                
                # Clean up temp file if needed
                if is_temp_file and installer_path:
                    os.unlink(installer_path)
                
                if result.returncode == 0:
                    self.manifest.remove_app(app_name)
                    print(f"[tw] [+] Removed: {app_name}")
                    return True
                else:
                    print(f"[tw] [X] Removal failed: {app_name}")
                    return False
                    
            except Exception as e:
                # Clean up temp file if needed
                if is_temp_file and installer_path:
                    try:
                        os.unlink(installer_path)
                    except:
                        pass
                print(f"[tw] [X] Error running installer: {e}")
                return False
        else:
            # Fallback: use manifest to remove files
            print(f"[tw] Installer not found, using manifest for removal")
            files = self.manifest.get_files(app_name)
            for file_path in files:
                path = Path(file_path)
                if path.exists():
                    path.unlink()
                    print(f"[tw]   Removed: {file_path}")
            
            self.manifest.remove_app(app_name)
            print(f"[tw] [+] Removed: {app_name}")
            return True
    
    def update(self, app_name):
        """Update an application safely using stage-then-install
        
        Flow:
          1. Download all new files to temp staging dir (preflight check)
          2. Verify checksums (if available)
          3. If staging fails -> old version stays completely intact
          4. If staging succeeds -> remove old, run real .install script
          5. If .install fails -> restore from staged backup
        
        The .install script remains the single source of truth for
        file placement, permissions, .taskrc, and manifest tracking.
        Python staging is purely a safety net / preflight download check.
        """
        if not self.manifest.is_installed(app_name):
            print(f"[tw] [!] Not installed: {app_name}")
            print(f"[tw] Use --install to install it")
            return False
        
        old_version = self.manifest.get_version(app_name)
        meta = self.registry.get_meta(app_name)
        if not meta:
            print(f"[tw] [X] Meta file not found for: {app_name}")
            return False
        
        new_version = meta.get('version', '?')
        
        if old_version == new_version:
            print(f"[tw] Already at v{new_version}")
            response = input("[tw] Reinstall anyway? [y/N]: ").strip().lower()
            if response != 'y':
                return True
        
        print(f"[tw] Updating {app_name}: v{old_version} -> v{new_version}")
        
        # Step 1: Preflight - download all new files to temp dir
        print(f"[tw] Preflight: staging new files...")
        staged = self._stage_downloads(app_name, meta)
        if not staged:
            print(f"[tw] [X] Preflight failed - v{old_version} is still installed")
            return False
        
        stage_dir = staged
        print(f"[tw] Preflight passed - all files downloaded and verified")
        
        # Step 2: Backup current installed files (from manifest)
        backup_dir = Path(tempfile.mkdtemp(prefix=f'tw-backup-{app_name}-'))
        debug(f"Backup directory: {backup_dir}", 2)
        
        installed_files = self.manifest.get_files(app_name)
        for file_path in installed_files:
            src = Path(file_path)
            if src.exists():
                dst = backup_dir / src.name
                shutil.copy2(src, dst)
                debug(f"Backed up: {src} -> {dst}", 2)
        
        # Also backup manifest entries for this app
        backup_manifest = [e.copy() for e in self.manifest.entries if e['app'] == app_name]
        
        # Step 3: Remove old version via installer
        print(f"[tw] Removing v{old_version}...")
        self.remove(app_name)
        
        # Step 4: Install new version via real .install script
        print(f"[tw] Installing v{new_version}...")
        if self.install(app_name):
            # Success - clean up staging and backup
            shutil.rmtree(stage_dir, ignore_errors=True)
            shutil.rmtree(backup_dir, ignore_errors=True)
            print(f"[tw] [+] Updated {app_name}: v{old_version} -> v{new_version}")
            return True
        else:
            # Install failed - restore from backup
            print(f"[tw] [X] Install failed! Restoring v{old_version}...")
            restore_ok = self._restore_backup(app_name, backup_dir, backup_manifest)
            
            # Clean up staging dir
            shutil.rmtree(stage_dir, ignore_errors=True)
            
            if restore_ok:
                print(f"[tw] [+] Restored v{old_version}")
            else:
                print(f"[tw] [X] Restore failed! Backup preserved at: {backup_dir}")
            
            return False
    
    def _stage_downloads(self, app_name, meta):
        """Download all files to a temp staging directory as a preflight check.
        
        This does NOT install anything - it just verifies that all files
        can be downloaded and checksums match before we touch the old version.
        
        Returns stage_dir Path on success, None on failure.
        """
        base_url = meta.get_base_url()
        if not base_url:
            print(f"[tw] [X] No base_url in meta for {app_name}")
            return None
        
        # Strip trailing slash from base_url to avoid double-slash
        base_url = base_url.rstrip('/')
        
        files = meta.get_files()
        checksums = meta.get_checksums()
        
        if not files:
            print(f"[tw] [X] No files listed in meta for {app_name}")
            return None
        
        # Create staging directory
        stage_dir = Path(tempfile.mkdtemp(prefix=f'tw-stage-{app_name}-'))
        debug(f"Staging directory: {stage_dir}", 2)
        
        for i, (filename, file_type) in enumerate(files):
            url = f"{base_url}/{filename}"
            staged_path = stage_dir / filename
            
            debug(f"Staging: {url} -> {staged_path}", 2)
            print(f"[tw]   Downloading: {filename}")
            
            try:
                result = subprocess.run(
                    ['curl', '-fsSL', url, '-o', str(staged_path)],
                    capture_output=True, text=True, timeout=30
                )
                if result.returncode != 0:
                    print(f"[tw] [X] Download failed: {filename}")
                    debug(f"curl error: {result.stderr}", 1)
                    shutil.rmtree(stage_dir, ignore_errors=True)
                    return None
            except subprocess.TimeoutExpired:
                print(f"[tw] [X] Download timed out: {filename}")
                shutil.rmtree(stage_dir, ignore_errors=True)
                return None
            except Exception as e:
                print(f"[tw] [X] Download error: {filename}: {e}")
                shutil.rmtree(stage_dir, ignore_errors=True)
                return None
            
            # Verify checksum if available
            if checksums and i < len(checksums) and checksums[i]:
                actual = self._calculate_checksum(staged_path)
                if actual != checksums[i]:
                    print(f"[tw] [X] Checksum mismatch: {filename}")
                    debug(f"Expected: {checksums[i]}", 1)
                    debug(f"Got:      {actual}", 1)
                    shutil.rmtree(stage_dir, ignore_errors=True)
                    return None
                debug(f"Checksum verified: {filename}", 2)
        
        print(f"[tw] [+] All {len(files)} files staged and verified")
        return stage_dir
    
    def _restore_backup(self, app_name, backup_dir, backup_manifest):
        """Restore files from backup after a failed update.
        
        Copies backed-up files back to their original locations
        and restores manifest entries.
        
        Returns True on success, False on failure.
        """
        try:
            # Restore files to their original locations using manifest paths
            for entry in backup_manifest:
                original_path = Path(entry['file'])
                backup_file = backup_dir / original_path.name
                
                if backup_file.exists():
                    # Ensure target directory exists
                    original_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(backup_file, original_path)
                    
                    # Restore executable bit if it was executable
                    if original_path.suffix in ('.py', '.sh', '') and original_path.name.startswith('on-'):
                        original_path.chmod(original_path.stat().st_mode | 0o755)
                    
                    debug(f"Restored: {backup_file} -> {original_path}", 2)
            
            # Restore manifest entries
            for entry in backup_manifest:
                self.manifest.entries.append(entry)
            self.manifest._save()
            
            # Clean up backup dir on success
            shutil.rmtree(backup_dir, ignore_errors=True)
            return True
        
        except Exception as e:
            print(f"[tw] [X] Restore error: {e}")
            return False
    
    def list_installed(self, tag_filter=None):
        """List all installed and available applications with optional tag filtering"""
        # Get installed apps from manifest
        installed = {}
        for entry in self.manifest.entries:
            app = entry['app']
            if app not in installed:
                installed[app] = entry['version']
        
        # Get all available apps from registry
        available = self.registry.list_apps()
        
        # Build combined list with status
        all_apps = {}
        for app in available:
            meta = self.registry.get_meta(app)
            if meta:
                version = meta.data.get('version', '?')
                tags = meta.get_tags()
                is_installed = app in installed
                all_apps[app] = {
                    'version': version,
                    'installed_version': installed.get(app, None),
                    'is_installed': is_installed,
                    'tags': tags
                }
        
        # Apply tag filter if provided
        if tag_filter and tag_filter.has_filters():
            filtered_apps = {}
            for app, info in all_apps.items():
                if tag_filter.matches(info['tags']):
                    filtered_apps[app] = info
            
            if not filtered_apps:
                print(f"[tw] No applications match filter: {tag_filter}")
                return
            
            all_apps = filtered_apps
            print(f"[tw] Applications (filtered by {tag_filter}):")
        else:
            print("[tw] Available applications:")
        
        if not all_apps:
            print("[tw] No applications in registry")
            return
        
        # Display apps with status indicators
        for app, info in sorted(all_apps.items()):
            if info['is_installed']:
                status = "[*] "
                version_str = f"v{info['installed_version']}"
            else:
                status = "[ ] "
                version_str = f"v{info['version']}"
            
            tags_str = ""
            if info['tags']:
                tags_str = f" [{', '.join(info['tags'])}]"
            
            print(f"[tw] {status}{app} ({version_str}){tags_str}")
        
        # Show legend
        print(f"\n[tw] Legend: [*] = installed, [ ] = available")
    
    def list_tags(self, app_names=None):
        """List all available tags from registry, optionally filtered by app names
        
        Args:
            app_names: List of app names to filter by, or None for all apps
        """
        tag_counts = {}
        
        # Scan all apps in registry
        apps = self.registry.list_apps()
        for app_name in apps:
            # Filter by app names if provided
            if app_names and app_name not in app_names:
                continue
            
            meta = self.registry.get_meta(app_name)
            if not meta:
                continue
            tags = meta.get_tags()
            
            for tag in tags:
                tag_counts[tag] = tag_counts.get(tag, 0) + 1
        
        if not tag_counts:
            if app_names:
                print(f"[tw] No tags found for: {', '.join(app_names)}")
            else:
                print("[tw] No tags found in registry")
            return
        
        # Display tags
        if app_names:
            print(f"[tw] Tags for {', '.join(app_names)}:")
        else:
            print("[tw] Available tags:")
        
        for tag, count in sorted(tag_counts.items()):
            print(f"[tw]   {tag} ({count} app{'s' if count != 1 else ''})")
    
    def show_info_all(self, tag_filter=None):
        """Show info for all available applications (installed or not)
        
        Args:
            tag_filter: Optional TagFilter to filter apps by tags
        """
        debug(f"show_info_all called, dev_mode={self.paths.is_dev_mode}", 2)
        
        # Get all apps from registry
        all_apps = []
        apps = self.registry.list_apps()
        debug(f"Found {len(apps)} apps in registry", 2)
        
        for app_name in apps:
            debug(f"Processing {app_name}", 3)
            
            # Apply tag filter if provided
            if tag_filter and tag_filter.has_filters():
                meta = self.registry.get_meta(app_name)
                if not meta:
                    continue
                tags = meta.get_tags()
                debug(f"App {app_name} has tags: {tags}", 3)
                if not tag_filter.matches(tags):
                    debug(f"App {app_name} filtered out by tag filter", 3)
                    continue
            
            all_apps.append(app_name)
        
        debug(f"Final app list: {all_apps}", 2)
        
        if not all_apps:
            if tag_filter and tag_filter.has_filters():
                print(f"[tw] No applications match filter: {tag_filter}")
            else:
                print(f"[tw] No applications found in registry")
            return False
        
        # Show info for each app
        if tag_filter and tag_filter.has_filters():
            print(f"[tw] Applications matching {tag_filter}:\n")
        else:
            print(f"[tw] All available applications:\n")
        
        for i, app_name in enumerate(sorted(all_apps)):
            if i > 0:
                print()  # Blank line between apps
            self.show_info(app_name)
        
        return True

    
    def show_info(self, app_name):
        """Show information about an application"""
        meta = self.registry.get_meta(app_name)
        
        if not meta:
            print(f"[tw] [X] Application not found: {app_name}")
            return False
        
        print(f"[tw] Application: {app_name}")
        print(f"[tw]   Name: {meta.get('name', 'N/A')}")
        print(f"[tw]   Version: {meta.get('version', 'N/A')}")
        print(f"[tw]   Type: {meta.get('type', 'N/A')}")
        print(f"[tw]   Description: {meta.get('description', 'N/A')}")
        print(f"[tw]   Repository: {meta.get('repo', 'N/A')}")
        print(f"[tw]   Base URL: {meta.get('base_url', 'N/A')}")
        
        # Show files
        files = meta.get_files()
        if files:
            print(f"[tw]   Files ({len(files)}):")
            for filename, file_type in files:
                print(f"[tw]     {filename} ({file_type})")
        
        # Show installation status
        if self.manifest.is_installed(app_name):
            installed_version = self.manifest.get_version(app_name)
            print(f"[tw]   Status: Installed (v{installed_version})")
            
            # Show README location if it exists
            readme_path = self.paths.docs_dir / f"{app_name}_README.md"
            if readme_path.exists():
                print(f"[tw]   README: {readme_path}")
        else:
            print(f"[tw]   Status: Not installed")
        
        return True
    
    def verify(self, app_name):
        """Verify checksums of installed files"""
        if not self.manifest.is_installed(app_name):
            print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ Not installed: {app_name}")
            return False
        
        meta = self.registry.get_meta(app_name)
        if not meta:
            print(f"[tw] [!] Meta file not found for: {app_name}")
            return False
        checksums = meta.get_checksums()
        files = meta.get_files()
        
        if not checksums:
            print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â  No checksums available for {app_name}")
            return True
        
        print(f"[tw] Verifying {app_name}...")
        all_valid = True
        
        for i, (filename, file_type) in enumerate(files):
            if i >= len(checksums):
                break
            
            expected_checksum = checksums[i]
            if not expected_checksum:
                continue
            
            # Find file path
            target_dir = self._get_target_dir(file_type)
            file_path = target_dir / filename
            
            if not file_path.exists():
                print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ File not found: {file_path}")
                all_valid = False
                continue
            
            # Calculate checksum
            actual_checksum = self._calculate_checksum(file_path)
            
            if actual_checksum == expected_checksum:
                print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ {filename}")
            else:
                print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ {filename} (checksum mismatch)")
                all_valid = False
        
        if all_valid:
            print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“ All files verified")
        else:
            print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ Verification failed")
        
        return all_valid
    
    def _get_target_dir(self, file_type):
        """Get target directory for a file type"""
        type_map = {
            'hook': self.paths.hooks_dir,
            'script': self.paths.scripts_dir,
            'config': self.paths.config_dir,
            'doc': self.paths.docs_dir
        }
        return type_map.get(file_type, self.paths.task_dir)
    
    def _calculate_checksum(self, file_path):
        """Calculate SHA256 checksum of a file"""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

class TaskShell:
    """Interactive shell for Taskwarrior with persistent modifiers
    
    Integrated into tw wrapper - uses "tw" as shell name instead of "task"
    """
    
    def __init__(self, initial_head=None, initial_prefix=None):
        self.head = initial_head if initial_head else []
        self.prefix_stack = initial_prefix if initial_prefix else []
        self.templates = {
            "meeting": ["proj:meetings", "+work", "pri:M"],
            "bug": ["proj:bugs", "+work", "pri:H"],
        }
        self._init_history()
    
    def _init_history(self):
        """Initialize readline history"""
        try:
            readline.read_history_file(SHELL_HISTFILE)
        except FileNotFoundError:
            pass
    
    def _save_history(self):
        """Save readline history"""
        readline.write_history_file(SHELL_HISTFILE)
    
    def _format_prompt(self):
        """Build prompt showing current state"""
        if self.head:
            parts = [SHELL_NAME] + self.head + self.prefix_stack
        else:
            if self.prefix_stack:
                parts = [SHELL_NAME] + self.prefix_stack
            else:
                parts = [SHELL_NAME]
        return " ".join(parts) + "> "
    
    def _run_task(self, args):
        """Execute task command with full passthrough of stdout/stderr"""
        subprocess.run(["task"] + args, check=False)
    
    def _get_context(self, name):
        """Activate context and return its filter definition"""
        # Activate the context
        subprocess.run(["task", "context", name], check=False)
        # Fetch its definition
        p = subprocess.run(
            ["task", "_get", f"rc.context.{name}"],
            capture_output=True,
            text=True,
        )
        return shlex.split(p.stdout.strip())
    
    def _show_help(self, detailed=False):
        """Show shell help"""
        if detailed:
            # Show detailed help (same as tw --help shell)
            print("""
Interactive Shell (tw --shell)
==============================

The interactive shell provides a stateful environment for running Taskwarrior
commands with persistent modifiers and command heads.

Starting the Shell:
  tw --shell                    Start with empty state
  tw --shell add                Start in 'add' mode
  tw --shell add +work          Start in 'add' mode with +work modifier
  tw --shell +work proj:foo     Start with modifiers (no command)

Shell Commands:
  :head <cmd>        Set command head (e.g., :head add, :head modify)
  :head              Clear command head (return to base prompt)
  :push <mods...>    Add persistent modifiers (e.g., :push +work proj:foo)
  :pop               Remove last modifier from stack
  :clear             Clear all modifiers
  :reset             Clear both head and modifiers
  :context <n>    Apply Taskwarrior context filters to modifier stack
  :tpl <n>        Apply a template (predefined modifier sets)
  :show              Display current HEAD and PREFIX_STACK state
  :help              Show this quick reference
  :help shell        Show detailed shell documentation
  :q, :quit, :exit   Exit shell

Shell Execution:
  exec <cmd>         Execute any shell command
  !<cmd>             Same as exec (e.g., !ls -la)
  !!                 Repeat last shell command

How it Works:
  Every command you type is prepended with HEAD + PREFIX_STACK
  Empty input (just pressing Enter) runs the default report
  
  Example session:
    tw> :push +work proj:meetings
    tw +work proj:meetings> :head add
    tw add +work proj:meetings> Schedule standup for Friday
    # Executes: task add +work proj:meetings Schedule standup for Friday
    
    tw add +work proj:meetings> :head
    tw +work proj:meetings> list
    # Executes: task +work proj:meetings list
    
    tw +work proj:meetings> 
    # Executes: task +work proj:meetings (default report)
    
    tw +work proj:meetings> :pop
    tw +work> 5 modify +urgent
    # Executes: task +work 5 modify +urgent

Templates:
  Built-in templates provide quick modifier sets:
  - meeting: proj:meetings +work pri:M
  - bug: proj:bugs +work pri:H
  
  Usage: :tpl meeting

History:
  Command history is saved to ~/.tw_shell_history
  Use arrow keys to navigate previous commands
""")
        else:
            # Show quick reference
            print("""
Commands:
  :head <args...>       set command head (e.g., :head add, :head modify)
  :head                 clear command head (return to base prompt)
  :push <mods...>       push persistent modifiers onto stack
  :pop                  pop last modifier from stack
  :clear                clear all modifiers from stack
  :context <n>       apply task context filters to stack
  :tpl <n>           apply a template to stack
  :show                 show current HEAD and PREFIX_STACK state
  :reset                reset both head and modifiers to empty
  :help                 show this quick reference
  :help shell           show detailed shell documentation
  :q | :quit | :exit    exit shell

Examples:
  :push +work proj:meetings
  :head add
  Schedule the standup
  # Runs: task add +work proj:meetings Schedule the standup

  :head
  list
  # Runs: task +work proj:meetings list
  
  (press Enter on empty line)
  # Runs: task +work proj:meetings (default report)
""".strip())
    
    def _handle_meta_command(self, cmd):
        """Handle meta-commands (commands starting with :)
        
        Returns True if shell should continue, False if it should exit
        """
        if not cmd:
            return True
        
        if cmd[0] in ("q", "quit", "exit"):
            return False
        
        elif cmd[0] == "help":
            # :help shell shows detailed help, :help shows quick reference
            detailed = len(cmd) > 1 and cmd[1] == "shell"
            self._show_help(detailed=detailed)
        
        elif cmd[0] == "head":
            # :head with no args clears HEAD to []
            self.head = cmd[1:] if len(cmd) > 1 else []
        
        elif cmd[0] == "push":
            self.prefix_stack.extend(cmd[1:])
        
        elif cmd[0] == "pop":
            if self.prefix_stack:
                self.prefix_stack.pop()
            else:
                print("PREFIX_STACK is empty")
        
        elif cmd[0] == "clear":
            self.prefix_stack.clear()
        
        elif cmd[0] == "reset":
            self.head = []
            self.prefix_stack.clear()
        
        elif cmd[0] == "show":
            print("HEAD:", self.head if self.head else "(empty)")
            print("PREFIX_STACK:", self.prefix_stack if self.prefix_stack else "(empty)")
        
        elif cmd[0] == "context":
            if len(cmd) > 1:
                context_filters = self._get_context(cmd[1])
                self.prefix_stack.extend(context_filters)
            else:
                print("Usage: :context <n>")
        
        elif cmd[0] == "tpl":
            if len(cmd) > 1:
                template = self.templates.get(cmd[1])
                if template:
                    self.prefix_stack.extend(template)
                else:
                    print(f"Unknown template: {cmd[1]}")
                    print(f"Available templates: {', '.join(self.templates.keys())}")
            else:
                print("Usage: :tpl <n>")
                print(f"Available templates: {', '.join(self.templates.keys())}")
        
        else:
            print(f"Unknown command: {cmd[0]}")
            print("Type :help for available commands")
        
        return True
    
    def run(self):
        """Run the interactive shell"""
        try:
            while True:
                line = input(self._format_prompt()).strip()
                
                # Empty input: run default report with current state
                if not line:
                    args = self.head + self.prefix_stack
                    if args:  # Only run if we have some state
                        self._run_task(args)
                    else:  # Completely empty - run bare 'task'
                        self._run_task([])
                    continue
                
                # Handle shell command execution (exec or !)
                if line.startswith('exec '):
                    shell_cmd = line[5:].strip()
                    if shell_cmd:
                        subprocess.run(shell_cmd, shell=True, check=False)
                    continue
                
                if line.startswith('!'):
                    if len(line) > 1 and line[1] == '!':
                        # !! - repeat last command (from history)
                        history_len = readline.get_current_history_length()
                        if history_len > 1:
                            # Get the command before the current one
                            last_cmd = readline.get_history_item(history_len - 1)
                            if last_cmd and not last_cmd.startswith('!'):
                                print(f"[tw-shell] Repeating: {last_cmd}")
                                subprocess.run(last_cmd, shell=True, check=False)
                            else:
                                print("[tw-shell] No previous command to repeat")
                        else:
                            print("[tw-shell] No command history")
                    else:
                        # Single ! - execute shell command
                        shell_cmd = line[1:].strip()
                        if shell_cmd:
                            subprocess.run(shell_cmd, shell=True, check=False)
                    continue
                
                # Handle meta-commands
                if line.startswith(":"):
                    cmd = shlex.split(line[1:])
                    if not self._handle_meta_command(cmd):
                        break  # Exit shell
                    continue
                
                # Build and execute task command
                # HEAD + PREFIX_STACK are always prepended to user input
                args = self.head + self.prefix_stack + shlex.split(line)
                self._run_task(args)
        
        except (EOFError, KeyboardInterrupt):
            print()
        finally:
            self._save_history()

def show_help_topic(topic):
    """Show detailed help for a specific topic"""
    topics = {
        'shell': """
Interactive Shell (tw --shell)
==============================

The interactive shell provides a stateful environment for running Taskwarrior
commands with persistent modifiers and command heads.

Starting the Shell:
  tw --shell                    Start with empty state
  tw --shell add                Start in 'add' mode
  tw --shell add +work          Start in 'add' mode with +work modifier
  tw --shell +work proj:foo     Start with modifiers (no command)

Shell Commands:
  :head <cmd>        Set command head (e.g., :head add, :head modify)
  :head              Clear command head (return to base prompt)
  :push <mods...>    Add persistent modifiers (e.g., :push +work proj:foo)
  :pop               Remove last modifier from stack
  :clear             Clear all modifiers
  :reset             Clear both head and modifiers
  :context <name>    Apply Taskwarrior context filters to modifier stack
  :tpl <name>        Apply a template (predefined modifier sets)
  :show              Display current HEAD and PREFIX_STACK state
  :help              Show shell help
  :q, :quit, :exit   Exit shell

Shell Execution:
  exec <cmd>         Execute any shell command
  !<cmd>             Same as exec (e.g., !ls -la, !cat file.txt)
  !!                 Repeat last shell command
  
  Examples:
    tw> exec ls -la
    tw> !grep "bug" notes.txt
    tw> !!

How it Works:
  Every command you type is prepended with HEAD + PREFIX_STACK
  
  Example session:
    tw> :push +work proj:meetings
    tw +work proj:meetings> :head add
    tw add +work proj:meetings> Schedule standup for Friday
    # Executes: task add +work proj:meetings Schedule standup for Friday
    
    tw add +work proj:meetings> :head
    tw +work proj:meetings> list
    # Executes: task +work proj:meetings list
    
    tw +work proj:meetings> :pop
    tw +work> 5 modify +urgent
    # Executes: task +work 5 modify +urgent

Templates:
  Built-in templates provide quick modifier sets:
  - meeting: proj:meetings +work pri:M
  - bug: proj:bugs +work pri:H
  
  Usage: :tpl meeting

History:
  Command history is saved to ~/.tw_shell_history
  Use arrow keys to navigate previous commands
""",
        'install': """
Package Installation (tw --install)
===================================

Install Taskwarrior extensions from the awesome-taskwarrior registry.

Usage:
  tw --install <app>        Install an application
  tw --install --dry-run <app>   Preview installation without changes

How it Works:
  1. Reads metadata from registry.d/<app>.meta
  2. Downloads files via curl from specified base_url
  3. Places files in appropriate directories (hooks/, scripts/, config/)
  4. Tracks installation in ~/.task/.tw_manifest
  5. Copies README to ~/.task/docs/

File Placement:
  - hook files  ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ ~/.task/hooks/
  - script files ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ ~/.task/scripts/
  - config files ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ ~/.task/config/
  - doc files    ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ ~/.task/docs/

Example:
  tw --install tw-recurrence-hooks
  tw --install --dry-run tw-need_priority
""",
        'remove': """
Package Removal (tw --remove)
==============================

Remove installed Taskwarrior extensions.

Usage:
  tw --remove <app>         Remove an application

How it Works:
  1. Runs the application's installer with --remove flag (if available)
  2. Falls back to manifest-based removal if installer not found
  3. Removes all tracked files
  4. Updates manifest

Safety:
  - Only removes files tracked in the manifest
  - Preserves user data and task database
  - Installer's --remove can perform custom cleanup

Example:
  tw --remove tw-recurrence-hooks
""",
        'verify': """
Package Verification (tw --verify)
===================================

Verify checksums of installed application files.

Usage:
  tw --verify <app>         Verify all files for an application

How it Works:
  1. Reads expected checksums from registry.d/<app>.meta
  2. Calculates SHA256 checksums of installed files
  3. Compares expected vs actual
  4. Reports any mismatches

Use Cases:
  - Verify installation integrity
  - Detect file modifications
  - Troubleshoot issues

Example:
  tw --verify tw-recurrence-hooks
""",
        'list': """
List Installed Packages (tw --list)
====================================

Show all installed applications and their versions.

Usage:
  tw --list                 List all installed packages

Output Format:
  [tw] Installed applications:
  [tw]   app-name (vX.Y.Z)
  [tw]   another-app (vA.B.C)

Example:
  tw --list
""",
        'info': """
Package Information (tw --info)
================================

Show detailed information about an application.

Usage:
  tw --info <app>           Show package details

Information Shown:
  - Name and description
  - Version
  - Type (hooks, script, etc.)
  - Repository URL
  - Base download URL
  - Files and their types
  - Installation status
  - README location (if installed)

Example:
  tw --info tw-recurrence-hooks
""",
    }
    
    if topic in topics:
        print(topics[topic])
        return True
    else:
        # Show available topics
        print(f"Unknown help topic: {topic}\n")
        print("Available help topics:")
        for t in sorted(topics.keys()):
            print(f"  {t}")
        print("\nUsage: tw --help <topic>")
        return False

def get_taskwarrior_version():
    """Get taskwarrior version"""
    try:
        result = subprocess.run(['task', '--version'], 
                              capture_output=True, text=True, check=True)
        # Output is like "2.6.2\n"
        return result.stdout.strip()
    except:
        return "unknown"

def get_installed_extensions(paths):
    """Get list of installed extensions with versions from manifest"""
    extensions = {}
    manifest_file = paths.config_dir / ".tw_manifest"
    
    if not manifest_file.exists():
        return extensions
    
    try:
        with open(manifest_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                # Format: appname|version|filepath|checksum|timestamp
                parts = line.split('|')
                if len(parts) >= 2:
                    app_name = parts[0]
                    version = parts[1]
                    # Store unique apps (manifest has one line per file)
                    if app_name not in extensions:
                        extensions[app_name] = version
    except:
        pass
    
    return extensions

def validate_first_arg_flag(args):
    """
    Validate that flags are only recognized when:
    1. They are the first argument
    2. They have a trailing space (not part of another word)
    3. They are known flags
    
    Returns: (is_valid_flag, error_message)
    """
    if not args or len(args) == 0:
        return (False, None)
    
    first_arg = args[0]
    
    # If first arg doesn't start with -, it's not a flag
    if not first_arg.startswith('-'):
        return (False, None)
    
    # Known tw flags
    known_short = ['-I', '-r', '-u', '-l', '-i', '-v', '-h', '-s', '-p', '-A']
    known_long = ['--install', '--remove', '--update', '--list', '--info', 
                  '--verify', '--tags', '--dry-run', '--debug', 
                  '--version', '--help', '--shell', '--pager', '--attach', '--generate-completion', '--install-completion']
    
    # Check if it's a known flag (exact match)
    if first_arg in known_short or first_arg in known_long:
        return (True, None)
    
    # Check for flags with = syntax (e.g., --debug=2)
    if '=' in first_arg:
        flag_part = first_arg.split('=')[0]
        if flag_part in known_long:
            return (True, None)
    
    # Check if it starts with a known flag but has no space (e.g., -lena)
    # This should NOT match - flags must be standalone
    for flag in known_short:
        if first_arg.startswith(flag) and len(first_arg) > len(flag):
            # This is something like "-lena" which should not match "-l"
            # Treat as unknown flag
            return (False, f"Unknown flag: {first_arg}")
    
    # Unknown flag starting with - or --
    if first_arg.startswith('-'):
        return (False, f"Unknown flag: {first_arg}")
    
    return (False, None)

def resolve_dot_shortcut(dot, debug_wrapper=False):
    """Resolve dot-shortcuts to task IDs or short UUIDs.
    
    .    = ID of most recently added task
    ..   = ID of most recently modified task
    ...  = short UUID (8 char) of most recently completed task
    ....  = short UUID (8 char) of most recently deleted task
    
    All queries use rc.context:none to work regardless of active context.
    Returns the resolved ID/UUID string, or None on failure.
    """
    labels = {
        '.':    'most recently added task',
        '..':   'most recently modified task',
        '...':  'most recently completed task',
        '....': 'most recently deleted task',
    }
    
    label = labels.get(dot)
    if not label:
        print(f"[tw] [X] Unknown dot-shortcut: {dot}")
        return None
    
    if debug_wrapper:
        print(f"[tw-debug] Resolving {dot} -> {label}", file=sys.stderr)
    
    if dot == '.':
        try:
            result = subprocess.run(
                ['task', 'rc.context:none', 'rc.verbose:nothing', 'newest', 'limit:1'],
                capture_output=True, text=True, check=False
            )
            # Parse the ID from the first column of output
            for line in result.stdout.strip().split('\n'):
                line = line.strip()
                if line and line.split()[0].isdigit():
                    task_id = line.split()[0]
                    if debug_wrapper:
                        print(f"[tw-debug] Resolved . -> {task_id}", file=sys.stderr)
                    print(f"[tw] . -> task {task_id}")
                    return task_id
        except Exception as e:
            if debug_wrapper:
                print(f"[tw-debug] Error resolving .: {e}", file=sys.stderr)
    
    elif dot == '..':
        # Most recently modified pending task
        try:
            result = subprocess.run(
                ['task', 'rc.context:none', 'rc.verbose:nothing',
                 'status:pending', 'export'],
                capture_output=True, text=True, check=False
            )
            if result.returncode == 0 and result.stdout.strip():
                tasks = json.loads(result.stdout)
                if tasks:
                    # Sort by modified timestamp, most recent first
                    tasks.sort(key=lambda t: t.get('modified', ''), reverse=True)
                    task_id = str(tasks[0].get('id', ''))
                    if task_id and task_id != '0':
                        if debug_wrapper:
                            print(f"[tw-debug] Resolved .. -> {task_id}", file=sys.stderr)
                        print(f"[tw] .. -> task {task_id}")
                        return task_id
        except Exception as e:
            if debug_wrapper:
                print(f"[tw-debug] Error resolving ..: {e}", file=sys.stderr)
    
    elif dot in ('...', '....'):
        # Completed or deleted - need UUID
        status = 'completed' if dot == '...' else 'deleted'
        sort_field = 'end'
        try:
            result = subprocess.run(
                ['task', 'rc.context:none', 'rc.verbose:nothing',
                 f'status:{status}', 'export'],
                capture_output=True, text=True, check=False
            )
            if result.returncode == 0 and result.stdout.strip():
                tasks = json.loads(result.stdout)
                if tasks:
                    # Sort by end timestamp, most recent first
                    tasks.sort(key=lambda t: t.get(sort_field, ''), reverse=True)
                    full_uuid = tasks[0].get('uuid', '')
                    if full_uuid:
                        short_uuid = full_uuid[:8]
                        if debug_wrapper:
                            print(f"[tw-debug] Resolved {dot} -> {short_uuid}", file=sys.stderr)
                        print(f"[tw] {dot} -> task {short_uuid}")
                        return short_uuid
        except Exception as e:
            if debug_wrapper:
                print(f"[tw-debug] Error resolving {dot}: {e}", file=sys.stderr)
    
    print(f"[tw] [X] No {label} found")
    return None


def handle_context_command(args):
    """Handle @ context commands - alias for 'context' with @+/- extensions"""
    if not args:
        # tw @ with no args Ã¢â€ â€™ show current context
        # First check if cmx is active
        current_cmx = get_cmx_contexts()
        if current_cmx:
            print(f"Context multiplexing active: {current_cmx}")
            combined_read = subprocess.run(
                ['task', '_get', 'rc.context.cmx.read'],
                capture_output=True, text=True, check=False
            ).stdout.strip()
            if combined_read:
                print(f"Combined filter: {combined_read}")
            return 0
        else:
            # No cmx, show regular context
            return subprocess.run(['task', 'context'], check=False).returncode
    
    first_arg = args[0]
    
    # Check for @+ (add context)
    if first_arg.startswith('+'):
        context_name = first_arg[1:]
        return add_context_to_cmx(context_name)
    
    # Check for @- (remove context)
    if first_arg.startswith('-'):
        context_name = first_arg[1:]
        return remove_context_from_cmx(context_name)
    
    # Otherwise, pass through to task context
    # tw @ list Ã¢â€ â€™ task context list
    # tw @ work Ã¢â€ â€™ task context work
    return subprocess.run(['task', 'context'] + args, check=False).returncode

def get_cmx_contexts():
    """Get current cmx.contexts value from taskrc"""
    try:
        result = subprocess.run(
            ['task', '_get', 'rc.cmx.contexts'],
            capture_output=True,
            text=True,
            check=False
        )
        return result.stdout.strip() if result.returncode == 0 else ""
    except:
        return ""

def is_context_defined(context_name):
    """Check if a context is defined in taskwarrior"""
    try:
        result = subprocess.run(
            ['task', '_get', f'rc.context.{context_name}.read'],
            capture_output=True,
            text=True,
            check=False
        )
        # If it returns successfully and has output, context exists
        return result.returncode == 0 and result.stdout.strip()
    except:
        return False

def get_context_filter(context_name, filter_type='read'):
    """Get the read or write filter for a context"""
    try:
        result = subprocess.run(
            ['task', '_get', f'rc.context.{context_name}.{filter_type}'],
            capture_output=True,
            text=True,
            check=False
        )
        return result.stdout.strip() if result.returncode == 0 else ""
    except:
        return ""

def build_combined_filter(contexts_str, filter_type='read'):
    """Build combined filter from comma-separated contexts"""
    if not contexts_str:
        return ""
    
    contexts = [c.strip() for c in contexts_str.split(',')]
    combined_parts = []
    
    for ctx in contexts:
        if not ctx:
            continue
        filter_str = get_context_filter(ctx, filter_type)
        if filter_str:
            combined_parts.append(f"( {filter_str} )")
    
    return " and ".join(combined_parts) if combined_parts else ""

def set_cmx_context(contexts_str):
    """Set the cmx context with combined filters"""
    try:
        if not contexts_str:
            # Clear everything
            subprocess.run(['task', 'config', 'cmx.contexts', ''], 
                         input='yes\n', text=True, check=False, 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run(['task', 'config', 'context.cmx.read', ''], 
                         input='yes\n', text=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run(['task', 'config', 'context.cmx.write', ''], 
                         input='yes\n', text=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run(['task', 'config', 'context', ''], 
                         input='yes\n', text=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print("Cleared all contexts")
            return 0
        
        # Validate all contexts exist
        contexts = [c.strip() for c in contexts_str.split(',')]
        for ctx in contexts:
            if not is_context_defined(ctx):
                print(f"[tw] Error: Context '{ctx}' is not defined")
                print(f"[tw] Use 'task context define {ctx} <filter>' to define it first")
                return 1
        
        # Build combined filters
        combined_read = build_combined_filter(contexts_str, 'read')
        combined_write = build_combined_filter(contexts_str, 'write')
        
        # Set cmx.contexts
        subprocess.run(['task', 'config', 'cmx.contexts', contexts_str],
                     input='yes\n', text=True, check=False,
                     stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Set context.cmx.read
        if combined_read:
            subprocess.run(['task', 'config', 'context.cmx.read', combined_read],
                         input='yes\n', text=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Set context.cmx.write if exists
        if combined_write:
            subprocess.run(['task', 'config', 'context.cmx.write', combined_write],
                         input='yes\n', text=True, check=False,
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Activate cmx context
        subprocess.run(['task', 'config', 'context', 'cmx'],
                     input='yes\n', text=True, check=False,
                     stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        print(f"Activated contexts: {contexts_str}")
        if combined_read:
            print(f"Combined filter: {combined_read}")
        return 0
        
    except Exception as e:
        print(f"[tw] Error setting context: {e}", file=sys.stderr)
        return 1

def add_context_to_cmx(context_name):
    """Add a context to the current cmx set"""
    if not is_context_defined(context_name):
        print(f"[tw] Error: Context '{context_name}' is not defined")
        print(f"[tw] Use 'task context define {context_name} <filter>' to define it first")
        return 1
    
    current = get_cmx_contexts()
    
    # Check if already in the list
    if current:
        current_list = [c.strip() for c in current.split(',')]
        if context_name in current_list:
            print(f"Context '{context_name}' is already active")
            return 0
        new_contexts = f"{current},{context_name}"
    else:
        new_contexts = context_name
    
    return set_cmx_context(new_contexts)

def remove_context_from_cmx(context_name):
    """Remove a context from the current cmx set"""
    current = get_cmx_contexts()
    
    if not current:
        print("No contexts are currently active")
        return 0
    
    current_list = [c.strip() for c in current.split(',')]
    
    if context_name not in current_list:
        print(f"Context '{context_name}' is not in the active set")
        return 0
    
    # Remove the context
    new_list = [c for c in current_list if c != context_name]
    new_contexts = ','.join(new_list) if new_list else ''
    
    return set_cmx_context(new_contexts)

def attach_file_to_task(task_id):
    """Attach a file to a task using ranger file browser"""
    try:
        # Check if ranger is installed
        ranger_bin = shutil.which('ranger')
        if not ranger_bin:
            print("[tw] Error: ranger is not installed")
            print("[tw] Install ranger to use file attachment feature")
            print("[tw] Debian/Ubuntu: sudo apt install ranger")
            print("[tw] Arch: sudo pacman -S ranger")
            print("[tw] macOS: brew install ranger")
            return 1
        
        # Find task executable
        task_bin = shutil.which('task')
        if not task_bin:
            print("[tw] Task executable not found")
            return 1
        
        # Get task description
        result = subprocess.run(
            [task_bin, task_id, 'info'],
            capture_output=True,
            text=True,
            check=False
        )
        
        if result.returncode != 0:
            print(f"[tw] Error: Could not find task {task_id}")
            return 1
        
        # Extract description from info output
        desc = ""
        for line in result.stdout.split('\n'):
            if line.startswith('Description'):
                # Extract everything after "Description"
                desc = line.split(None, 1)[1] if len(line.split(None, 1)) > 1 else ""
                break
        
        print(f"[tw] Attaching to task {task_id}: '{desc}'")
        
        # Prompt for label
        print("[tw] Type a label (or press Enter for none): ", end='', flush=True)
        label = input().strip()
        
        # Create temp file for ranger output
        temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.ranger')
        temp_filename = temp_file.name
        temp_file.close()
        
        # Launch ranger
        print("[tw] Launching ranger... (press 'q' to cancel)")
        ranger_result = subprocess.run(
            [ranger_bin, f'--choosefile={temp_filename}'],
            check=False
        )
        
        # Read selected file
        try:
            with open(temp_filename, 'r') as f:
                selected_file = f.read().strip()
        except:
            selected_file = ""
        finally:
            os.unlink(temp_filename)
        
        if not selected_file:
            print("[tw] No file selected, attachment cancelled")
            return 0
        
        # Build annotation
        annotation = f"{label}: {selected_file}" if label else selected_file
        
        # Add annotation to task
        result = subprocess.run(
            [task_bin, task_id, 'annotate', '--', annotation],
            check=False
        )
        
        if result.returncode == 0:
            print(f"[tw] Ã¢Å“â€œ Attached: {annotation}")
        
        return result.returncode
        
    except KeyboardInterrupt:
        print("\n[tw] Attachment cancelled")
        return 1
    except Exception as e:
        print(f"[tw] Error attaching file: {e}", file=sys.stderr)
        return 1

def run_with_pager(task_args):
    """Run task command with pager - simple pipe like tless"""
    try:
        # Get terminal width
        cols = os.popen('tput cols', 'r').read().strip()
        
        # Find task executable
        task_bin = shutil.which('task')
        if not task_bin:
            print("[tw] Task executable not found")
            return 1
        
        # Find pager
        pager = shutil.which('less') or shutil.which('more')
        if not pager:
            # No pager, just run task normally
            return pass_through_to_task(task_args)
        
        # Build shell command - try to override ALL possible limits
        args_str = ' '.join(shlex.quote(arg) for arg in task_args) if task_args else ''
        
        # Override multiple limit/lines settings to catch all reports
        # Some reports use 'limit', some use 'lines'
        overrides = (
            f"rc._forcecolor=on "
            f"rc.defaultwidth={cols} "
            f"rc.limit=0 "
            f"rc.report.next.limit=0 "
            f"rc.report.next.lines=0 "  # next uses 'lines' not 'limit'!
            f"rc.report.list.limit=0 "
            f"rc.report.all.limit=0 "
            f"rc.report.ls.limit=0"
        )
        
        shell_cmd = f"{task_bin} {args_str} {overrides} 2>/dev/null | {pager} -R -X"
        
        # Debug
        if os.environ.get('TW_DEBUG_WRAPPER', '0') != '0':
            print(f"[tw-debug] Pager shell command:", file=sys.stderr)
            print(f"[tw-debug]   {shell_cmd}", file=sys.stderr)
        
        # Execute the pipeline
        result = subprocess.run(shell_cmd, shell=True, check=False)
        return result.returncode
        
    except Exception as e:
        print(f"[tw] Error using pager: {e}", file=sys.stderr)
        # Fall back to normal execution
        return pass_through_to_task(task_args)

def pass_through_to_task(args):
    """Pass command through to task"""
    try:
        # Find task executable
        task_bin = shutil.which('task')
        if not task_bin:
            print("[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ task executable not found")
            return 1
        
        # Execute task with arguments
        result = subprocess.run([task_bin] + args, check=False)
        return result.returncode
        
    except Exception as e:
        print(f"[tw] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã¯Â¿Â½ Error executing task: {e}")
        return 1

def generate_bash_completion():
    """Generate bash completion script for tw"""
    return '''# Bash completion for tw (awesome-taskwarrior package manager)
# Generated by: tw --generate-completion bash
#
# Installation:
#   tw --generate-completion bash > ~/.bash_completion.d/tw.sh
#   source ~/.bash_completion.d/tw.sh
#
# Or add to ~/.bashrc:
#   source ~/.bash_completion.d/tw.sh

# Get available apps from registry
_tw_get_available_apps() {
    local registry_dir=""
    if [[ -n "${TW_REGISTRY_DIR:-}" ]]; then
        registry_dir="$TW_REGISTRY_DIR"
    elif [[ -d "$HOME/dev/awesome-taskwarrior/registry.d" ]]; then
        registry_dir="$HOME/dev/awesome-taskwarrior/registry.d"
    else
        registry_dir="$HOME/.task/registry"
    fi
    
    if [[ -d "$registry_dir" ]]; then
        ls "$registry_dir"/*.meta 2>/dev/null | xargs -n1 basename | sed 's/\\.meta$//'
    fi
}

# Get installed apps from manifest
_tw_get_installed_apps() {
    local manifest="$HOME/.task/.tw_manifest"
    if [[ -f "$manifest" ]]; then
        cut -d'|' -f1 "$manifest" | sort -u
    fi
}

# Get help topics
_tw_get_help_topics() {
    echo "shell install remove verify list info"
}

# Main completion function for tw
_tw() {
    local cur prev opts base
    
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # tw-specific flags
    local tw_flags="-I --install -r --remove -u --update -l --list -i --info --verify --tags --dry-run --debug -v --version -h --help -s --shell -p --pager -A --attach --generate-completion"
    
    # Check if we're completing a tw command or should pass through to task
    local i=1
    local found_tw_cmd=0
    
    # Look for tw-specific flags in the command line
    while [[ $i -lt $COMP_CWORD ]]; do
        case "${COMP_WORDS[$i]}" in
            -I|--install|-r|--remove|-u|--update|-l|--list|-i|--info|--verify|--tags|--dry-run|--debug|-v|--version|-h|--help|-s|--shell|-p|--pager|-A|--attach|--generate-completion)
                found_tw_cmd=1
                break
                ;;
        esac
        ((i++))
    done
    
    # Handle completions based on previous word
    case "${prev}" in
        tw)
            # First position - offer both tw flags and task commands
            if [[ ${cur} == -* ]]; then
                COMPREPLY=( $(compgen -W "${tw_flags}" -- ${cur}) )
                return 0
            else
                # Offer task commands via task _commands
                local task_cmds=$(task _commands 2>/dev/null)
                COMPREPLY=( $(compgen -W "${task_cmds}" -- ${cur}) )
                return 0
            fi
            ;;
        -I|--install)
            # Complete with available apps from registry
            COMPREPLY=( $(compgen -W "$(_tw_get_available_apps)" -- ${cur}) )
            return 0
            ;;
        -r|--remove|-u|--update|--verify)
            # Complete with installed apps
            COMPREPLY=( $(compgen -W "$(_tw_get_installed_apps)" -- ${cur}) )
            return 0
            ;;
        -i|--info)
            # Complete with all available apps
            COMPREPLY=( $(compgen -W "$(_tw_get_available_apps)" -- ${cur}) )
            return 0
            ;;
        -h|--help)
            # Complete with help topics
            COMPREPLY=( $(compgen -W "$(_tw_get_help_topics)" -- ${cur}) )
            return 0
            ;;
        -A|--attach)
            # Complete with task IDs
            local task_ids=$(task _ids 2>/dev/null)
            COMPREPLY=( $(compgen -W "${task_ids}" -- ${cur}) )
            return 0
            ;;
        --generate-completion)
            # Complete with shell types
            COMPREPLY=( $(compgen -W "bash zsh fish" -- ${cur}) )
            return 0
            ;;
        --debug)
            # Complete with debug levels
            COMPREPLY=( $(compgen -W "1 2 3" -- ${cur}) )
            return 0
            ;;
    esac
    
    # If we found a tw command earlier, don't pass through to task
    if [[ $found_tw_cmd -eq 1 ]]; then
        # For tag filtering on --list, --info
        case "${cur}" in
            +*)
                local tags=$(task _tags 2>/dev/null | sed 's/^/+/')
                COMPREPLY=( $(compgen -W "${tags}" -- ${cur}) )
                return 0
                ;;
            -*)
                # Could be a flag or a negative tag
                if [[ ${#cur} -gt 1 ]] && [[ ${cur:1:1} != "-" ]]; then
                    # Single dash followed by non-dash = negative tag
                    local tags=$(task _tags 2>/dev/null | sed 's/^/-/')
                    COMPREPLY=( $(compgen -W "${tags}" -- ${cur}) )
                else
                    # It's a flag
                    COMPREPLY=( $(compgen -W "${tw_flags}" -- ${cur}) )
                fi
                return 0
                ;;
        esac
        return 0
    fi
    
    # Pass through to task completion
    # Try to source the task completion if available
    if declare -f _task >/dev/null 2>&1; then
        _task
        return 0
    fi
    
    # Fallback: basic task command completion
    case "${cur}" in
        +*)
            local tags=$(task _tags 2>/dev/null | sed 's/^/+/')
            COMPREPLY=( $(compgen -W "${tags}" -- ${cur}) )
            ;;
        -*)
            local tags=$(task _tags 2>/dev/null | sed 's/^/-/')
            COMPREPLY=( $(compgen -W "${tags}" -- ${cur}) )
            ;;
        project:*|pro:*)
            local projects=$(task _projects 2>/dev/null)
            COMPREPLY=( $(compgen -W "${projects}" -- ${cur/*:/}) )
            ;;
        *)
            local task_cmds=$(task _commands 2>/dev/null)
            COMPREPLY=( $(compgen -W "${task_cmds}" -- ${cur}) )
            ;;
    esac
    
    return 0
}

# Register the completion function
complete -F _tw tw
'''

def generate_zsh_completion():
    """Generate zsh completion script for tw"""
    return '''#compdef tw
# Zsh completion for tw (awesome-taskwarrior package manager)
# Generated by: tw --generate-completion zsh
#
# Installation:
#   tw --generate-completion zsh > ~/.zsh/completion/_tw
#   # Add to ~/.zshrc if needed:
#   fpath=(~/.zsh/completion $fpath)
#   autoload -Uz compinit && compinit

# Get available apps from registry
_tw_available_apps() {
    local registry_dir=""
    if [[ -n "${TW_REGISTRY_DIR:-}" ]]; then
        registry_dir="$TW_REGISTRY_DIR"
    elif [[ -d "$HOME/dev/awesome-taskwarrior/registry.d" ]]; then
        registry_dir="$HOME/dev/awesome-taskwarrior/registry.d"
    else
        registry_dir="$HOME/.task/registry"
    fi
    
    if [[ -d "$registry_dir" ]]; then
        local -a apps
        apps=(${(f)"$(ls "$registry_dir"/*.meta 2>/dev/null | xargs -n1 basename | sed 's/\\.meta$//')"})
        _describe 'available apps' apps
    fi
}

# Get installed apps from manifest
_tw_installed_apps() {
    local manifest="$HOME/.task/.tw_manifest"
    if [[ -f "$manifest" ]]; then
        local -a apps
        apps=(${(f)"$(cut -d'|' -f1 "$manifest" | sort -u)"})
        _describe 'installed apps' apps
    fi
}

# Get help topics
_tw_help_topics() {
    local -a topics
    topics=(
        'shell:Interactive shell guide'
        'install:Package installation'
        'remove:Package removal'
        'verify:Package verification'
        'list:List installed packages'
        'info:Package information'
    )
    _describe 'help topics' topics
}

# Get shell types
_tw_shell_types() {
    local -a shells
    shells=(
        'bash:Bash shell completion'
        'zsh:Zsh shell completion'
        'fish:Fish shell completion'
    )
    _describe 'shell types' shells
}

# Main completion function
_tw() {
    local curcontext="$curcontext" state line
    typeset -A opt_args
    
    # Check if we should delegate to task completion
    local -a task_commands
    task_commands=(${(f)"$(task _commands 2>/dev/null)"})
    
    _arguments -C \\
        '(-I --install)'{-I,--install}'[Install an application]:app:_tw_available_apps' \\
        '(-r --remove)'{-r,--remove}'[Remove an application]:app:_tw_installed_apps' \\
        '(-u --update)'{-u,--update}'[Update an application]:app:_tw_installed_apps' \\
        '(-l --list)'{-l,--list}'[List installed applications]' \\
        '(-i --info)'{-i,--info}'[Show application info]::app:_tw_available_apps' \\
        '--verify[Verify application checksums]:app:_tw_installed_apps' \\
        '--tags[List all available tags]' \\
        '--dry-run[Show what would be done]' \\
        '--debug[Enable debug output]::level:(1 2 3)' \\
        '(-v --version)'{-v,--version}'[Show tw version]' \\
        '(-h --help)'{-h,--help}'[Show help]::topic:_tw_help_topics' \\
        '(-s --shell)'{-s,--shell}'[Start interactive shell]' \\
        '(-p --pager)'{-p,--pager}'[Use pager for task output]' \\
        '(-A --attach)'{-A,--attach}'[Attach file to task]:taskid' \\
        '--generate-completion[Generate completion script]:shell:_tw_shell_types' \\
        '*::task commands:->task_args'
    
    case $state in
        task_args)
            # Pass through to task completion if available
            if (( $+functions[_task] )); then
                _task
            else
                # Basic fallback completion
                local -a task_cmds
                task_cmds=(${(f)"$(task _commands 2>/dev/null)"})
                _describe 'task commands' task_cmds
            fi
            ;;
    esac
}

_tw "$@"
'''

def generate_fish_completion():
    """Generate fish completion script for tw"""
    return '''# Fish completion for tw (awesome-taskwarrior package manager)
# Generated by: tw --generate-completion fish
#
# Installation:
#   tw --generate-completion fish > ~/.config/fish/completions/tw.fish

# Helper functions
function __fish_tw_available_apps
    set -l registry_dir ""
    if set -q TW_REGISTRY_DIR
        set registry_dir "$TW_REGISTRY_DIR"
    else if test -d "$HOME/dev/awesome-taskwarrior/registry.d"
        set registry_dir "$HOME/dev/awesome-taskwarrior/registry.d"
    else
        set registry_dir "$HOME/.task/registry"
    end
    
    if test -d "$registry_dir"
        ls $registry_dir/*.meta 2>/dev/null | xargs -n1 basename | sed 's/\\.meta$//'
    end
end

function __fish_tw_installed_apps
    set -l manifest "$HOME/.task/.tw_manifest"
    if test -f "$manifest"
        cut -d'|' -f1 "$manifest" | sort -u
    end
end

function __fish_tw_help_topics
    echo "shell"
    echo "install"
    echo "remove"
    echo "verify"
    echo "list"
    echo "info"
end

function __fish_tw_needs_app
    # Check if the previous argument is a flag that needs an app name
    set -l cmd (commandline -opc)
    if test (count $cmd) -ge 2
        switch $cmd[-1]
            case -I --install -r --remove -u --update --verify -i --info
                return 0
        end
    end
    return 1
end

function __fish_tw_needs_help_topic
    set -l cmd (commandline -opc)
    if test (count $cmd) -ge 2
        switch $cmd[-1]
            case -h --help
                return 0
        end
    end
    return 1
end

function __fish_tw_using_command
    set -l cmd (commandline -opc)
    if test (count $cmd) -gt 1
        for tw_cmd in -I --install -r --remove -u --update -l --list -i --info --verify --tags -v --version -h --help -s --shell -p --pager -A --attach --generate-completion
            if contains -- $tw_cmd $cmd
                return 0
            end
        end
    end
    return 1
end

# Completion specifications
# Package management
complete -c tw -s I -l install -d "Install an application" -x -a "(__fish_tw_available_apps)"
complete -c tw -s r -l remove -d "Remove an application" -x -a "(__fish_tw_installed_apps)"
complete -c tw -s u -l update -d "Update an application" -x -a "(__fish_tw_installed_apps)"
complete -c tw -s l -l list -d "List installed applications"
complete -c tw -s i -l info -d "Show application info" -x -a "(__fish_tw_available_apps)"
complete -c tw -l verify -d "Verify application checksums" -x -a "(__fish_tw_installed_apps)"
complete -c tw -l tags -d "List all available tags"
complete -c tw -l dry-run -d "Show what would be done"
complete -c tw -l debug -d "Enable debug output" -x -a "1 2 3"

# Utility commands
complete -c tw -s v -l version -d "Show tw version"
complete -c tw -s h -l help -d "Show help" -x -a "(__fish_tw_help_topics)"
complete -c tw -s s -l shell -d "Start interactive shell"
complete -c tw -s p -l pager -d "Use pager for task output"
complete -c tw -s A -l attach -d "Attach file to task" -x
complete -c tw -l generate-completion -d "Generate completion script" -x -a "bash zsh fish"

# Tag completion (for --list, --info with filters)
complete -c tw -n "__fish_tw_using_command" -a "+(__fish_use_subcommand; and task _tags)" -d "Include tag"
complete -c tw -n "__fish_tw_using_command" -a "-(__fish_use_subcommand; and task _tags)" -d "Exclude tag"

# Pass through to task completion for non-tw commands
# Only complete task commands if no tw flags have been used
complete -c tw -n "not __fish_tw_using_command" -a "(task _commands 2>/dev/null)" -d "Task command"
complete -c tw -n "not __fish_tw_using_command" -a "+(__fish_use_subcommand; and task _tags)" -d "Include tag"
complete -c tw -n "not __fish_tw_using_command" -a "-(__fish_use_subcommand; and task _tags)" -d "Exclude tag"
'''

def install_completion(shell):
    """Install completion script for the specified shell"""
    import os
    from pathlib import Path
    
    shell = shell.lower()
    home = Path.home()
    
    # Determine target path and script content
    if shell == 'bash':
        target_dir = home / '.bash_completion.d'
        target_file = target_dir / 'tw.sh'
        script_content = generate_bash_completion()
        source_line = f'source {target_file}'
        rc_file = home / '.bashrc'
    elif shell == 'zsh':
        target_dir = home / '.zsh' / 'completion'
        target_file = target_dir / '_tw'
        script_content = generate_zsh_completion()
        source_line = None  # zsh uses fpath, handled differently
        rc_file = home / '.zshrc'
    elif shell == 'fish':
        target_dir = home / '.config' / 'fish' / 'completions'
        target_file = target_dir / 'tw.fish'
        script_content = generate_fish_completion()
        source_line = None  # fish auto-loads completions
        rc_file = None
    else:
        return (False, f"Unknown shell type '{shell}'")
    
    try:
        # Create directory if it doesn't exist
        target_dir.mkdir(parents=True, exist_ok=True)
        
        # Write completion script
        target_file.write_text(script_content)
        print(f"[tw] Wrote completion script to: {target_file}")
        
        # Shell-specific setup
        if shell == 'bash':
            # Check if already sourced in .bashrc
            if rc_file.exists():
                rc_content = rc_file.read_text()
                if source_line not in rc_content:
                    print(f"[tw] Add this line to {rc_file}:")
                    print(f"[tw]   {source_line}")
                else:
                    print(f"[tw] Already configured in {rc_file}")
            else:
                print(f"[tw] Add this line to {rc_file}:")
                print(f"[tw]   {source_line}")
            
            print(f"[tw] To activate now: source {target_file}")
            
        elif shell == 'zsh':
            # Check fpath configuration
            if rc_file.exists():
                rc_content = rc_file.read_text()
                fpath_line = f'fpath=({target_dir} $fpath)'
                compinit_line = 'autoload -Uz compinit && compinit'
                
                needs_fpath = str(target_dir) not in rc_content and 'fpath=' not in rc_content
                needs_compinit = 'compinit' not in rc_content
                
                if needs_fpath or needs_compinit:
                    print(f"[tw] Add these lines to {rc_file}:")
                    if needs_fpath:
                        print(f"[tw]   {fpath_line}")
                    if needs_compinit:
                        print(f"[tw]   {compinit_line}")
                else:
                    print(f"[tw] Completion path already configured in {rc_file}")
            else:
                print(f"[tw] Add these lines to {rc_file}:")
                print(f"[tw]   fpath=({target_dir} $fpath)")
                print(f"[tw]   autoload -Uz compinit && compinit")
            
            print(f"[tw] To activate now: exec zsh")
            
        elif shell == 'fish':
            print(f"[tw] Fish will auto-load completions on next shell start")
            print(f"[tw] To activate now: exec fish")
        
        return (True, None)
        
    except Exception as e:
        return (False, f"Failed to install completion: {e}")

def main():
    """Main entry point"""
    # Debug support via TW_DEBUG_WRAPPER environment variable
    # Set TW_DEBUG_WRAPPER=1 to see argument parsing flow
    debug_wrapper = os.environ.get('TW_DEBUG_WRAPPER', '0') != '0'
    
    if debug_wrapper:
        print(f"[tw-debug] sys.argv = {sys.argv}", file=sys.stderr)
    
    # Check if we have any arguments
    if len(sys.argv) < 2:
        # No arguments, pass empty to argparse to show help
        if debug_wrapper:
            print(f"[tw-debug] No arguments, showing help", file=sys.stderr)
        pass
    else:
        # Resolve dot-shortcuts to task IDs/UUIDs (first arg only)
        # .    = ID of most recently added task
        # ..   = ID of most recently modified task
        # ...  = short UUID of most recently completed task
        # .... = short UUID of most recently deleted task
        if sys.argv[1] in ('.', '..', '...', '....'):
            resolved = resolve_dot_shortcut(sys.argv[1], debug_wrapper)
            if resolved is None:
                return 1
            sys.argv[1] = resolved
            if debug_wrapper:
                print(f"[tw-debug] After dot resolution: sys.argv = {sys.argv}", file=sys.stderr)
        
        # Check for @ context command (special case - not a flag)
        if sys.argv[1].startswith('@'):
            if debug_wrapper:
                print(f"[tw-debug] Context command detected: {sys.argv[1]}", file=sys.stderr)
            
            # Handle different @ formats:
            # tw @            show current context
            # tw @ list       pass through to task context
            # tw @+ work      add context to cmx set
            # tw @- morning   remove context from cmx set
            # tw @0           context none
            # tw @: ctxname   one-shot context override (rc.context:name)
            # tw @_ [args]    one-shot no-context (rc.context:none)
            # tw @?           context show
            
            if sys.argv[1] == '@':
                # Simple @ - pass remaining args as-is
                return handle_context_command(sys.argv[2:])
            
            elif sys.argv[1] == '@0':
                # @0 = context none
                if debug_wrapper:
                    print(f"[tw-debug] @0 -> task context none", file=sys.stderr)
                return subprocess.run(['task', 'context', 'none'], check=False).returncode
            
            elif sys.argv[1] == '@?':
                # @? = context show
                if debug_wrapper:
                    print(f"[tw-debug] @? -> task context show", file=sys.stderr)
                return subprocess.run(['task', 'context', 'show'], check=False).returncode
            
            elif sys.argv[1] == '@:':
                # @: contextname [args] = one-shot context override
                if len(sys.argv) > 2:
                    ctx_name = sys.argv[2]
                    rest = sys.argv[3:]
                    if debug_wrapper:
                        print(f"[tw-debug] @: -> task rc.context:{ctx_name} {rest}", file=sys.stderr)
                    return subprocess.run(['task', f'rc.context:{ctx_name}'] + rest, check=False).returncode
                else:
                    print("[tw] Error: @: requires a context name")
                    print("[tw] Usage: tw @: contextname [task args]")
                    return 1
            
            elif sys.argv[1] == '@_':
                # @_ [args] = one-shot no-context override
                rest = sys.argv[2:]
                if debug_wrapper:
                    print(f"[tw-debug] @_ -> task rc.context:none {rest}", file=sys.stderr)
                return subprocess.run(['task', 'rc.context:none'] + rest, check=False).returncode
            
            elif sys.argv[1] == '@+':
                # @+ with space - combine with next arg
                if len(sys.argv) > 2:
                    return handle_context_command(['+' + sys.argv[2]] + sys.argv[3:])
                else:
                    print("[tw] Error: @+ requires a context name")
                    return 1
            elif sys.argv[1] == '@-':
                # @- with space - combine with next arg
                if len(sys.argv) > 2:
                    return handle_context_command(['-' + sys.argv[2]] + sys.argv[3:])
                else:
                    print("[tw] Error: @- requires a context name")
                    return 1
            else:
                # @+context or @-context (no space)
                return handle_context_command([sys.argv[1][1:]] + sys.argv[2:])
        
        # Validate first argument if it looks like a flag
        is_valid, error_msg = validate_first_arg_flag(sys.argv[1:])
        
        if debug_wrapper:
            print(f"[tw-debug] first_arg = '{sys.argv[1]}'", file=sys.stderr)
            print(f"[tw-debug] is_valid = {is_valid}, error_msg = {error_msg}", file=sys.stderr)
        
        if error_msg:
            # Unknown flag error
            print(f"[tw] Error: {error_msg}")
            print("[tw] Use 'tw --help' for usage information")
            return 1
        
        if not is_valid and sys.argv[1].startswith('-'):
            # First arg looks like a flag but isn't valid - already handled above
            if debug_wrapper:
                print(f"[tw-debug] Flag-like but invalid, continuing", file=sys.stderr)
            pass
        elif not is_valid:
            # First arg is not a flag at all - pass through to task immediately
            if debug_wrapper:
                print(f"[tw-debug] First arg not a tw flag, passing through to task", file=sys.stderr)
                print(f"[tw-debug] Executing: task {' '.join(sys.argv[1:])}", file=sys.stderr)
            return pass_through_to_task(sys.argv[1:])
    
    # If we get here, either no args or first arg is a valid tw flag
    if debug_wrapper:
        print(f"[tw-debug] First arg is valid tw flag, processing with argparse", file=sys.stderr)
    
    # CRITICAL: Only let argparse see consecutive flags from the start
    # Once we hit a non-flag argument, everything after should pass through
    # Special handling: flags that take arguments need their arg included
    flags_with_args = ['-I', '-r', '-u', '-i', '-A', '--install', '--remove', 
                      '--update', '--info', '--attach', '--verify', '--generate-completion', '--install-completion']
    
    args_for_parser = []
    remaining_args = []
    found_non_flag = False
    expect_flag_arg = False  # True if previous flag expects an argument
    
    for arg in sys.argv[1:]:
        if found_non_flag:
            # Already found a non-flag, rest goes to remaining
            remaining_args.append(arg)
        elif expect_flag_arg:
            # This is the argument for the previous flag
            args_for_parser.append(arg)
            expect_flag_arg = False
        elif arg.startswith('-'):
            # This is a flag-like argument
            args_for_parser.append(arg)
            # Check if this flag expects an argument
            flag_base = arg.split('=')[0]  # Handle --flag=value
            if flag_base in flags_with_args and '=' not in arg:
                # Flag expects separate argument
                expect_flag_arg = True
        else:
            # First non-flag argument (and not expected by a flag)
            found_non_flag = True
            remaining_args.append(arg)
    
    if debug_wrapper:
        print(f"[tw-debug] args_for_parser = {args_for_parser}", file=sys.stderr)
        print(f"[tw-debug] remaining_args = {remaining_args}", file=sys.stderr)
    
    parser = argparse.ArgumentParser(
        description='awesome-taskwarrior package manager and wrapper',
        add_help=False
    )
    
    # Package management commands
    parser.add_argument('-I', '--install', metavar='APP', help='Install an application')
    parser.add_argument('-r', '--remove', metavar='APP', help='Remove an application')
    parser.add_argument('-u', '--update', metavar='APP', help='Update an application')
    parser.add_argument('-l', '--list', action='store_true', help='List installed applications')
    parser.add_argument('-i', '--info', nargs='?', const='', metavar='APP', help='Show application info (all apps if no name given)')
    parser.add_argument('--verify', metavar='APP', help='Verify application checksums')
    parser.add_argument('--tags', action='store_true', help='List all available tags (optional: filter by app names)')
    parser.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser.add_argument('--debug', nargs='?', const='1', metavar='LEVEL', help='Enable debug output (1-3, default: 1)')
    
    # Utility commands
    parser.add_argument('-v', '--version', action='store_true', help='Show tw version')
    parser.add_argument('-h', '--help', action='store_true', help='Show this help')
    parser.add_argument('-s', '--shell', action='store_true', help='Start interactive shell (optional: command and modifiers)')
    parser.add_argument('-p', '--pager', action='store_true', help='Use pager for task output')
    parser.add_argument('-A', '--attach', metavar='TASKID', help='Attach file to task using ranger')
    parser.add_argument('--generate-completion', metavar='SHELL', help='Generate completion script (bash|zsh|fish)')
    parser.add_argument('--install-completion', metavar='SHELL', help='Install completion script (bash|zsh|fish)')
    
    # Parse ONLY the consecutive flags from the beginning
    # Use our pre-split args_for_parser instead of letting argparse scan everything
    args, extra = parser.parse_known_args(args_for_parser)
    
    # Combine any unparsed flags with our remaining_args
    remaining = extra + remaining_args
    
    if debug_wrapper:
        print(f"[tw-debug] Parsed args: {vars(args)}", file=sys.stderr)
        print(f"[tw-debug] Final remaining: {remaining}", file=sys.stderr)
    
    # Initialize paths
    paths = PathManager()
    paths.init_directories()
    
    # Initialize debug logger if requested
    global debug_logger
    if args.debug:
        try:
            level = int(args.debug)
            if level < 1 or level > 3:
                print("[tw] Debug level must be 1-3, using 1")
                level = 1
        except ValueError:
            print(f"[tw] Invalid debug level '{args.debug}', using 1")
            level = 1
        
        debug_logger = DebugLogger(level=level)
        debug_logger.set_environment()
        debug(f"tw v{VERSION} debug session started", 1)
        debug(f"Debug log: {debug_logger.log_file}", 1)
    
    # Handle tw commands
    if args.version:
        # Show taskwarrior version
        tw_version = get_taskwarrior_version()
        print(f"taskwarrior {tw_version}")
        print(f"tw v{VERSION}")
        
        # Show installed extensions
        extensions = get_installed_extensions(paths)
        if extensions:
            print("\nInstalled extensions:")
            for app_name in sorted(extensions.keys()):
                print(f"  {app_name} v{extensions[app_name]}")
        
        return 0
    
    if args.help:
        # Check if there are trailing args for topic help
        if remaining and remaining[0] not in ['--help', '--version']:
            # Topic-specific help
            return 0 if show_help_topic(remaining[0]) else 1
        
        # General help
        parser.print_help()
        print("\nInteractive Shell:")
        print("  tw --shell                 Start interactive shell")
        print("  tw --shell add +work       Start shell with command and modifiers")
        print("  tw --shell +work proj:foo  Start shell with modifiers")
        print("\nFor detailed help on specific features:")
        print("  tw --help shell            Interactive shell guide")
        print("  tw --help install          Package installation")
        print("  tw --help remove           Package removal")
        print("  tw --help verify           Package verification")
        print("  tw --help list             List installed packages")
        print("  tw --help info             Package information")
        print("\nDebug and Tags:")
        print("  tw --debug[=LEVEL]         Enable debug output (1-3)")
        print("  tw --tags [app ...]        List all tags (optional: for specific apps)")
        print("  tw --list +tag -tag        List installed apps with tag filter")
        print("  tw --info                  Show info for all available apps")
        print("  tw --info app1 app2        Show info for specific apps")
        print("  tw --info +python          Show info for apps matching tag filter")
        print("\nWrapper Debug:")
        print("  TW_DEBUG_WRAPPER=1 tw ...  Show argument parsing flow")
        print("  Example: TW_DEBUG_WRAPPER=1 tw add test --shell")
        print("\nPager and Attach:")
        print("  tw -p                      Page default report")
        print("  tw -p list                 Use pager for long output")
        print("  tw --pager next +work      Page through next work tasks")
        print("  tw -A 42                   Attach file to task 42 using ranger")
        print("  tw --attach 42             Same as -A 42")
        print("\nContext Multiplexing:")
        print("  tw @                       Show current context (alias for 'task context')")
        print("  tw @ list                  List all defined contexts")
        print("  tw @ work                  Switch to work context")
        print("  tw @+ personal             Add personal context to current set")
        print("  tw @- work                 Remove work context from current set")
        print("  tw @ none                  Clear all contexts")
        print("\nContext Shortcuts:")
        print("  tw @0                      Context none (clear active context)")
        print("  tw @: ctxname [args]       One-shot context override")
        print("  tw @_ [args]               One-shot no-context override")
        print("  tw @?                      Show active context details")
        print("\nDot Shortcuts:")
        print("  tw .  [cmd]                Most recently added task (by ID)")
        print("  tw .. [cmd]                Most recently modified task (by ID)")
        print("  tw ... [cmd]               Most recently completed task (by UUID)")
        print("  tw .... [cmd]              Most recently deleted task (by UUID)")
        print("\nTag Filtering:")
        print("  Use +tag to include, -tag to exclude")
        print("  Applies to: --list, --info")
        print("\nCompletion:")
        print("  tw --install-completion bash    Install bash completion (recommended)")
        print("  tw --install-completion zsh     Install zsh completion (recommended)")
        print("  tw --install-completion fish    Install fish completion (recommended)")
        print("  tw --generate-completion bash   Generate bash completion (manual)")
        print("  tw --generate-completion zsh    Generate zsh completion (manual)")
        print("  tw --generate-completion fish   Generate fish completion (manual)")
        print("\nFor Taskwarrior help: tw help")
        return 0
    
    # Handle completion generation
    if args.generate_completion:
        shell = args.generate_completion.lower()
        if shell == 'bash':
            print(generate_bash_completion())
            return 0
        elif shell == 'zsh':
            print(generate_zsh_completion())
            return 0
        elif shell == 'fish':
            print(generate_fish_completion())
            return 0
        else:
            print(f"[tw] Error: Unknown shell type '{args.generate_completion}'")
            print("[tw] Supported shells: bash, zsh, fish")
            return 1
    
    # Handle completion installation
    if args.install_completion:
        shell = args.install_completion.lower()
        if shell not in ['bash', 'zsh', 'fish']:
            print(f"[tw] Error: Unknown shell type '{args.install_completion}'")
            print("[tw] Supported shells: bash, zsh, fish")
            return 1
        
        success, error = install_completion(shell)
        if success:
            return 0
        else:
            print(f"[tw] Error: {error}")
            return 1
    
    # Handle attach before other commands
    if args.attach:
        return attach_file_to_task(args.attach)
    
    # Handle pager - if set, use pager for remaining task command
    if args.pager:
        if remaining:
            return run_with_pager(remaining)
        else:
            # No command given - use default report
            return run_with_pager([])
    
    if args.shell:
        # Parse trailing arguments after --shell
        # Separate command (first arg) from modifiers
        shell_args = remaining if remaining else []
        
        initial_head = []
        initial_prefix = []
        
        if shell_args:
            # First arg is the command (e.g., "add", "modify", "list")
            # Commands are single words without : or + or =
            if shell_args[0] and not any(c in shell_args[0] for c in ['+', ':', '=']):
                initial_head = [shell_args[0]]
                initial_prefix = shell_args[1:]
            else:
                # Everything is modifiers
                initial_prefix = shell_args
        
        shell = TaskShell(initial_head=initial_head, initial_prefix=initial_prefix)
        shell.run()
        return 0
    
    # Package management commands
    app_manager = AppManager(paths)
    
    # Show dev mode indicator if in dev mode and using package management
    def show_dev_mode_if_needed():
        """Show dev mode indicator for package management commands"""
        if paths.is_dev_mode:
            print(f"[tw] DEV MODE - using local registry: {paths.local_registry}")
    
    # Parse tag filters from remaining args (look for +/- tags)
    tag_filter = None
    tag_args = [arg for arg in remaining if arg.startswith(('+', '-'))]
    app_names = [arg for arg in remaining if not arg.startswith(('+', '-', '--'))]
    
    if tag_args:
        tag_filter = TagFilter(tag_args)
        debug(f"Tag filter created: {tag_filter}", 2)
    
    # Handle --tags command (list tags)
    if args.tags:
        show_dev_mode_if_needed()
        # Use app_names from remaining args if provided
        app_manager.list_tags(app_names if app_names else None)
        return 0
    
    if args.install:
        show_dev_mode_if_needed()
        # Tag filter applies to install
        if tag_filter:
            print(f"[tw] Note: Tag filtering not implemented for --install yet")
        return 0 if app_manager.install(args.install, dry_run=args.dry_run) else 1
    
    if args.remove:
        show_dev_mode_if_needed()
        # Tag filter applies to remove
        if tag_filter:
            print(f"[tw] Note: Tag filtering not implemented for --remove yet")
        return 0 if app_manager.remove(args.remove) else 1
    
    if args.update:
        show_dev_mode_if_needed()
        # Tag filter applies to update
        if tag_filter:
            print(f"[tw] Note: Tag filtering not implemented for --update yet")
        return 0 if app_manager.update(args.update) else 1
    
    if args.list:
        show_dev_mode_if_needed()
        # Tag filter applies to list
        app_manager.list_installed(tag_filter)
        return 0
    
    if args.info is not None:
        show_dev_mode_if_needed()
        # args.info will be '' if just --info with no immediate argument
        # or will be the app name if provided like --info myapp
        
        if args.info:
            # Single app specified directly: --info myapp
            if tag_filter:
                # Check if this app matches the filter
                meta_path = paths.registry_dir / f"{args.info}.meta"
                if meta_path.exists():
                    meta = MetaFile(meta_path)
                    tags = meta.get_tags()
                    if not tag_filter.matches(tags):
                        print(f"[tw] Application '{args.info}' does not match filter: {tag_filter}")
                        return 1
            return 0 if app_manager.show_info(args.info) else 1
        
        elif app_names:
            # Multiple apps from remaining args: --info app1 app2
            for app_name in app_names:
                if tag_filter:
                    # Check if this app matches the filter
                    meta_path = paths.registry_dir / f"{app_name}.meta"
                    if meta_path.exists():
                        meta = MetaFile(meta_path)
                        tags = meta.get_tags()
                        if not tag_filter.matches(tags):
                            continue  # Skip apps that don't match
                app_manager.show_info(app_name)
                print()  # Blank line between apps
            return 0
        
        else:
            # No app specified: --info (show all, optionally filtered by tags)
            return 0 if app_manager.show_info_all(tag_filter) else 1
    
    if args.verify:
        show_dev_mode_if_needed()
        return 0 if app_manager.verify(args.verify) else 1
    
    # If no tw commands, pass through to task
    if remaining or (not any(vars(args).values())):
        return pass_through_to_task(remaining if remaining else sys.argv[1:])
    
    return 0

if __name__ == '__main__':
    sys.exit(main())
